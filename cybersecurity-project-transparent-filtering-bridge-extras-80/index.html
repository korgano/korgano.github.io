<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 8.0 - XS Tech Thoughts</title><meta name="description" content="%pagetitle: Xavier Santana overcomes FreeBSD issues to implement Transparent Filtering Bridge cybersecurity project."><meta name="generator" content="Publii Open-Source CMS for Static Site"><!-- Global site tag (gtag.js) - Google Analytics --><script type="gdpr-blocker/Analytics" async src="https://www.googletagmanager.com/gtag/js?id=G-EHLH28GQMY"></script><script type="gdpr-blocker/Analytics">window.dataLayer = window.dataLayer || [];
				  function gtag(){dataLayer.push(arguments);}
				  gtag('js', new Date());
				  gtag('config', 'G-EHLH28GQMY' , { 'anonymize_ip': true });
				  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EHLH28GQMY"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EHLH28GQMY');</script><link rel="stylesheet" href="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-black.css"><link rel="stylesheet" href="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-inline-color.css"><link rel="canonical" href="https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-80/"><link rel="alternate" type="application/atom+xml" href="https://korgano.github.io/feed.xml" title="XS Tech Thoughts - RSS"><meta property="og:title" content="CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 8.0"><meta property="og:image" content="https://korgano.github.io/media/posts/41/cyber-proj-tfb11-2.png"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="921"><meta property="og:site_name" content="XS Tech Thoughts"><meta property="og:description" content="%pagetitle: Xavier Santana overcomes FreeBSD issues to implement Transparent Filtering Bridge cybersecurity project."><meta property="og:url" content="https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-80/"><meta property="og:type" content="article"><link rel="preload" href="https://korgano.github.io/assets/dynamic/fonts/robotoflex/robotoflex.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://korgano.github.io/assets/dynamic/fonts/robotoslab/robotoslab.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://korgano.github.io/assets/css/style.css?v=338ed96ce9bc0f6c72a02763a377a303"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-80/"},"headline":"CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 8.0","datePublished":"2025-06-17T11:13-04:00","dateModified":"2025-07-02T07:45-04:00","image":{"@type":"ImageObject","url":"https://korgano.github.io/media/posts/41/cyber-proj-tfb11-2.png","height":921,"width":1920},"description":"%pagetitle: Xavier Santana overcomes FreeBSD issues to implement Transparent Filtering Bridge cybersecurity project.","author":{"@type":"Person","name":"Xavier Santana","url":"https://korgano.github.io/authors/xavier-santana/"},"publisher":{"@type":"Organization","name":"Xavier Santana"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template lines"><div class="container lines lines--right"><header class="header"><a href="https://korgano.github.io/" class="logo">XS Tech Thoughts</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu">Menu</button><ul class="navbar__menu"><li><a href="https://korgano.github.io/" title="Home" target="_self">Home</a></li><li><a href="https://korgano.github.io/tags/uxui-case-study/" title="UX/UI Case Studies" target="_blank">UX/UI Case Studies</a></li><li><a href="https://korgano.github.io/tags/cybersecurity-projects/" title="Cybersecurity Projects" target="_blank">Cybersecurity Projects</a></li><li><a href="https://korgano.github.io/tags/quick-thoughts/" title="Quick Thoughts" target="_self">Quick Thoughts</a></li><li><a href="https://korgano.github.io/about-me/" title="About Me" target="_blank">About Me</a></li></ul></nav></header><main class="main post"><article class="content"><header class="content__inner content__header"><h1 class="content__title">CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 8.0</h1><div class="content__meta"><div class="content__meta__left"><a href="https://korgano.github.io/authors/xavier-santana/" class="invert content__author" rel="author" title="Xavier Santana">Xavier Santana</a></div><div class="content__meta__right"><time datetime="2025-06-17T11:13" class="content__date">June 17, 2025</time><div class="content__updated">Updated on <time datetime="2025-06-17T11:13" class="content__date">July 2, 2025</time></div></div></div></header><figure class="content__featured-image"><div class="content__featured-image__inner is-img-loading"><img src="https://korgano.github.io/media/posts/41/cyber-proj-tfb11-2.png" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-2-xs.png 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-2-sm.png 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-2-md.png 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-2-lg.png 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-2-xl.png 1600w" sizes="(min-width: 37.5em) 1600px, 80vw" loading="eager" height="921" width="1920" alt="OPNSense traffic reporting graphs showing incoming and outgoing traffic on the bridge and WiFi connections."></div></figure><div class="content__inner"><div class="content__entry"><p>Sometimes, things take far longer than they should.</p><p>This project was not intended to take roughly a year to implement. But <a href="https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-70/" title="CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 7.0" target="_blank" rel="noopener noreferrer">massive issues with the Intel WiFi driver</a> that shipped in the FreeBSD OS that OPNSense is based on created an impassible progression blocker. Since my plan was to place a transparent filtering bridge between the modem and router of my network by using a miniPC's ethernet ports, I needed to have a management interface via WiFi.</p><p>And if the WiFi wasn't reliable, then I could not access the miniPC at a moment's notice for monitoring or configuration adjustment. Even worse, I would have to take down the entire internet connection and bridge configuration, since I would have disconnect the miniPC from the router, connect it to a PC, set a static IP on the ethernet port, and use that as a management interface... then reconfigure that port for use in the bridge.</p><p>This was clearly a non-viable solution, but luckily, things changed in my favor.</p><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1itvd7nh328">What Changed?</a></li><li><a href="#mcetoc_1iv5fa9lq1tf">Initial Results</a></li><li><a href="#mcetoc_1iv5fa9lq1tg">The 25.1.8 Problem</a></li><li><a href="#mcetoc_1iv5fa9lq1th">The State Problem</a></li><li><a href="#mcetoc_1iv5fa9lq1ti">Uploading Aliases</a></li><li><a href="#mcetoc_1iv5fa9lq1tj">Configuring the Transparent Filtering Bridge</a></li><li><a href="#mcetoc_1iv5fa9lq1tk">Implementing Suricata IPS</a></li><li><a href="#mcetoc_1iv5fa9lq1tl">Validating the Bridge</a></li><li><a href="#mcetoc_1iv5fa9lq1tm">Figuring Out Connectivity Issues</a></li><li><a href="#mcetoc_1iv5fa9lq1tn">The Next Steps</a></li></ul></div><h2 id="mcetoc_1itvd7nh328">What Changed?</h2><p>Two main things:</p><ol><li><a href="https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=274382" title="Bug 274382 - iwlwifi Invalid TXQ id (FIXED)" target="_blank" rel="noopener noreferrer">A number of updates to the driver in question (<code>iwlwifi</code>)</a>, with the latest being in mid-May 2025.</li><li><a href="https://forum.opnsense.org/index.php?topic=47575.0" title="OPNsense 25.1.8 released" target="_blank" rel="noopener noreferrer">OPNSense 25.1.8 integrating a number of FreeBSD commits (which included the <code>iwlwifi</code>) commits.</a></li></ol><p>With the high probability that the new driver updates would solve the problems and were integrated into OPNSense, I rolled the dice and installed a fresh copy of OPNSense onto the miniPC.</p><h2 id="mcetoc_1iv5fa9lq1tf">Initial Results</h2><p>Thanks to my prior experience with OPNSense installation, the process went smoothly, although in a somewhat time consuming manner due to the speed of the USB drive installation media.</p><p>Having documented the process of installing the Realtek ethernet driver required to enable the miniPC's ethernet ports, I referred to my own past writing to complete that task.</p><p>The install media only provided OPNSense 25.1, which had enough of the driver updates to mitigate the usual errors that interfered with WiFi connectivity. However, despite utilizing the console and webGUI, I could not get the miniPC to connect to WiFi network.</p><p>So I chose to brute force the connection via the shell, querying Bing Copilot:</p><blockquote><p>Below are two common methods to have your <code>wpa_supplicant</code> rules execute automatically on boot in OPNsense (which, being FreeBSDâ€‘based, uses the traditional rc system). You can either create a custom rc.d startup script or add the command to your <code>/etc/rc.local</code>Â file.</p><hr><p><strong>Method 1: Creating a Custom rc.d Script</strong><br><br>1. Create the Script File<br><br>Open your favorite editor and create a file (for example, <code>/usr/local/etc/rc.d/wpa_supplicant</code>) with the following content. Adjust the interface (here shown as <code>wlan0</code>), driver (if needed), and path to your configuration file:<br><br>Â Â  <code>#!/bin/sh</code><br><code>Â Â  #</code><br><code>Â Â  # PROVIDE: wpa_supplicant</code><br><code>Â Â  # REQUIRE: NETWORKING</code><br><code>Â Â  # KEYWORD: shutdown</code><br><br><code>Â Â  . /etc/rc.subr</code><br><br><code>Â Â  name="wpa_supplicant"</code><br><code>Â Â  rcvar=wpa_supplicant_enable</code><br><code>Â Â  command="/usr/sbin/wpa_supplicant"</code><br><code>Â Â  command_args="-B -i wlan0 -c /etc/wpa_supplicant.conf"</code><br><br><code>Â Â  load_rc_config $name</code><br><code>Â Â  : ${wpa_supplicant_enable:=NO}</code><br><br><code>Â Â  run_rc_command "$1"</code><br><br>2. Make the Script Executable</p><p>Run the following command to ensure your new script can be executed:<br><br><code>Â Â  chmod +x /usr/local/etc/rc.d/wpa_supplicant</code><br><br><br>3. Enable the Service<br><br>Add the following line to <code>/etc/rc.conf.local</code>Â to tell the system to start your script on boot:<br><br><code>Â Â  wpa_supplicant_enable="YES"</code><br><br>4. Test Your Setup<br><br>Â Â  Manually start it with:<br><br><code>Â Â  /usr/local/etc/rc.d/wpa_supplicant start</code><br><br>Â Â  Verify that the process is running (using <code>ps</code>Â or checking your logs) before performing a reboot.</p></blockquote><p>With this script, wireless connectivity was achieved once the firewall was disabled. I then initiated an update to get the latest patch.</p><h2 id="mcetoc_1iv5fa9lq1tg">The 25.1.8 Problem</h2><p>However, once I updated to 25.1.8, I noticed a major issue - there was no IP address associated with the WiFi interface. Rebooting revealed errors related to the firmware for the WiFi card:</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb08a.jpg" alt="FreeBSD boot up sequence showing that Intel WiFi iwlwifi firmware was not present." width="3569" height="2734" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08a-xs.jpg 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08a-sm.jpg 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08a-md.jpg 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08a-lg.jpg 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08a-xl.jpg 1600w"></figure><p>Looking at the 25.1.8 release notes indicated that this was an intentional omission:</p><blockquote><p>o src: iwlwififw: remove Intel iwlwifi firmware from src.git</p></blockquote><p>My initial plan to solve this issue was to simply find a copy of the file from a reputable source, download it, and copy it to the <code>/boot/firmware</code> directory. Unfortunately, anything I downloaded off the internet produced the following error:</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb08b.jpg" alt="Downloaded firmware file for Intel WiFi iwlwifi produces &quot;File too small&quot; error on boot." width="3000" height="3064" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08b-xs.jpg 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08b-sm.jpg 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08b-md.jpg 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08b-lg.jpg 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08b-xl.jpg 1600w"></figure><p>This forced me to setup Windows Subsystem for Linux (WSL), then clone the repository containing the Intel WiFi firmware, and compile it. The resulting file was 1.45MB, andÂ <strong>thatÂ </strong>allowed the WiFi card to boot. (<a href="https://github.com/korgano/iwlwifi-firmware/" title="Compiled versions of Intel WiFi iwlwifi firmware for use in OPNSense/FreeBSD/Linux systems " target="_blank" rel="noopener noreferrer">I have a new Github repo for hosting these files.</a>)</p><p>Having regained the WiFi connection, I then had to troubleshoot the connection issue.</p><h2 id="mcetoc_1iv5fa9lq1th">The State Problem</h2><p>Looking over the final iwlwifi bug report entries pointed me in a new direction for the issues with WiFi connection and the firewall:</p><blockquote><p>A commit in branch releng/14.3 references this bug:<br><br>URL: https://cgit.FreeBSD.org/src/commit/?id=36174c38f9e3433e7fdb8b2f2923499dff67b2e7<br><br>commit 36174c38f9e3433e7fdb8b2f2923499dff67b2e7<br>Author: Â  Â  Bjoern A. Zeeb &lt;bz@FreeBSD.org&gt;<br>AuthorDate: 2025-05-12 15:12:39 +0000<br>Commit: Â  Â  Bjoern A. Zeeb &lt;bz@FreeBSD.org&gt;<br>CommitDate: 2025-05-15 19:13:58 +0000<br><br>Â  Â  LinuxKPI: 802.11: make sure AUTH frames are not being sent if BSS changed<br><br>Â  Â  iwlwifi keeps logging 'Invalid TXQ id' even after previous changes to<br>Â  Â  catch the BSS changed. Â The reason for this is that we do not error in<br>Â  Â  the SCAN -&gt; AUTH path as otherwise we would not have the state machine<br>Â  Â  get us back to SCAN to clear up firmware state before auth/assoc to the<br>Â  Â  new BSS.<br><br>Â  Â  If we are not in synch as net80211 just swapped the iv_bss from under us,<br>Â  Â  disable the TX queue for the (old) lsta to prevent the AUTH frame sent<br>Â  Â  from sta_newstate() reaching the driver. Â After all we are not trying to<br>Â  Â  authenticate to that node (sta) anymore.<br><br>Â  Â  Sponsored by: Â  The FreeBSD Foundation<br>Â  Â  PR: Â  Â  Â  Â  Â  Â  274382<br>Â  Â  Approved by: Â  Â re (cperciva)<br><br>Â  Â  (cherry picked from commit 16d987fe781780100a31df30b9edd79ebb54f957)<br>Â  Â  (cherry picked from commit e0692e7bb6e8abcc55a2510dceea5f83e823a827)<br><br>Â sys/compat/linuxkpi/common/src/linux_80211.c | 24 ++++++++++++++----------<br>Â 1 file changed, 14 insertions(+), 10 deletions(-)</p></blockquote><p>The key phrase in there is "the state machine."</p><p>What if monitoring the state of the connection was causing the problems? What if it was blocking connections because the driver wasn't updating states properly?</p><p>To test this out, I created the following three rules:</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb08c.png" alt="OPNSense WiFi interface rules to access router, let in HTTPS, and let out HTTPs." width="1920" height="921" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08c-xs.png 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08c-sm.png 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08c-md.png 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08c-lg.png 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08c-xl.png 1600w"></figure><p>The first rule would allow in all connections from the gateway router to the firewall. The second would let in HTTPS connections from any device on the network the WiFi interface was connected to. The third would let out HTTPS connections to that network.</p><p>These rules were configured through the webGUI on one of the ethernet interfaces, allowing me to re-enable the firewall and iterate through various settings.</p><p>Implementing the gateway router rule allowed me to ping the miniPC and ping other hosts from the miniPC, along with ensure that the router received a response to its queries. This did not resolve issues with the webGUI, but at least resolved issues regarding general connectivity.</p><p>The HTTPS in rule did not immediately provide connectivity, so I began experimenting with the states.</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb08d.png" alt="OPNSense rule page help for setting states." width="1599" height="474" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08d-xs.png 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08d-sm.png 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08d-md.png 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08d-lg.png 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb08d-xl.png 1600w"></figure><p>Since the initial <code>Keep state</code> option was causing the issues, I chose to use the <code>Sloppy state</code> option next. This did not allow for webGUI access over the WiFi connection either. For whatever reason, <code>None</code> was the proper value, and that allowed me to consistently connect to the webGUI.</p><p>Unfortunately, there was a caveat to this, which I'll get into later.</p><h2 id="mcetoc_1iv5fa9lq1ti">Uploading Aliases</h2><p><a href="https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-60/" target="_blank" rel="noopener noreferrer">The last two articles I did regarding this project</a> <a href="https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-70/" target="_blank" rel="noopener noreferrer">showed how to create Alias lists for blocking purposes</a>.</p><p>Following the steps outlined in those posts, I generated updated lists of IPs to block on the bridge, and uploaded them to OPNSense. I vetted them to ensure that no false positives were being generated by the Python scripts.</p><p>For some reason, there was a certain subset of IP addresses with an <code>8.#.#.#</code> structure that OPNSense refused to accept as valid IPs. These prevented me from uploading Aliases until they were removed.</p><h2 id="mcetoc_1iv5fa9lq1tj">Configuring the Transparent Filtering Bridge</h2><figure class="post__video"><iframe loading="lazy" width="560" height="314" src="https://www.youtube-nocookie.com/embed/Rb4vlN_Hf-U" allowfullscreen="allowfullscreen" data-mce-fragment="1"></iframe></figure><p>With network connectivity secured and the aliases uploaded, setting up the transparent filtering bridge was simple and straightforward, thanks to the above tutorial and past experience.</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb10.png" alt="Transparent Filtering Bridge configuration with multiple aliases, blocking potential threat traffic from entering or exiting the network." width="1920" height="918" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb10-xs.png 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb10-sm.png 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb10-md.png 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb10-lg.png 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb10-xl.png 1600w"></figure><p>Using the aliases allowed me to block large swathes of IP addresses without much issue. The <code>Allow All</code> rule at the bottom ensures that all non-rule matching traffic goes through, allowing for proper connectivity.</p><p>With this setup, I moved on to provisioning Suricata IPS.Â </p><h2 id="mcetoc_1iv5fa9lq1tk">Implementing Suricata IPS</h2><p>Thanks to the aforementioned Transparent Filtering Bridge tutorial, configuring Suricata was also simple.</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb09.png" alt="Suricata rule options for TP-LINK Devices." width="1920" height="894" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09-xs.png 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09-sm.png 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09-md.png 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09-lg.png 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09-xl.png 1600w"></figure><p>With the wide range of rule lists available, it was somewhat challenging to figure out the best sets for my use case. Thankfully, I found a Proofpoint document explaining the <code>Emerging Threat</code> list categories, which allowed me to pick a smaller subset of the full ruleset list.</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb09a.png" alt="OPNSense Suricata IPS policies set for use on the Transparent Filtering Bridge." width="1920" height="918" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09a-xs.png 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09a-sm.png 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09a-md.png 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09a-lg.png 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb09a-xl.png 1600w"></figure><p>OPNSense's implementation of Suricata includes <code>Policies</code>, which allow users to simplify the detection rule process. For example, the first policy on the list applies to malicious traffic targeting TP-Link routers, by using the <code>affected_product</code> field, which is just one of at least 20 different fields that you can use to fine tune a set of rules to match your systems.</p><p>To start off defending a home network, I decided to focus on a few primary attack vectors:</p><ol><li>The router.</li><li>Crypto-miners (in case any had gotten on to the network).</li><li>DNS tunneling (an exfiltration vector I find interesting).</li><li>Phishing (because it's ubiquitious.</li><li>JavaScript attacks (because JS is a blight).</li></ol><p>In addition, I implemented some pure monitoring alerts based on OPNSense's own rule lists, just to test that functionality and see if I needed to add more policies to address media sharing and messaging traffic.</p><h2 id="mcetoc_1iv5fa9lq1tl">Validating the Bridge</h2><p>With the bridge and Suricata configured, it was time to validate that traffic was coming in and out of the network.</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb11.png" alt="OPNSense traffic reporting graphs showing incoming and outgoing traffic on the bridge and WiFi connections." width="1920" height="921" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-xs.png 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-sm.png 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-md.png 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-lg.png 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb11-xl.png 1600w"></figure><p>Understandably, there was a lot more total traffic going in than there was coming out, with the exception being the WiFi interface, which was pumping out a decent amount of traffic to my computer as it updated the graphs every 2 seconds.</p><p>To get more information, I decided to examine the Top Talkers tab:</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb12-4.png" alt="OPNSense Top Talkers, showing incoming and outgoing traffic statistics." width="1920" height="921" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb12-4-xs.png 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb12-4-sm.png 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb12-4-md.png 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb12-4-lg.png 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb12-4-xl.png 1600w"></figure><p>While none of the traffic was particularly noteworthy in terms of totals in or out, there were some interesting IP addresses, which will bear exploration in the future.Â </p><h2 id="mcetoc_1iv5fa9lq1tm">Figuring Out Connectivity Issues</h2><p>One persistent issue with the WiFi connection was that, despite finally having a management connection through the router to any device I needed, the miniPC would eventually become inaccessible after some amount of time.</p><p>Unlike earlier iterations of the problem, there was a simple solution - reloading the various services via the console. Once that was done, the WiFi interface would be reenabled.</p><p>However, that required physical access to the miniPC and a keyboard. Since this seemed to be a recurring issue, I needed an automated way to address the issue. Luckily, OPNSense has built in provisions for `cron` jobs, so I configured a job to execute every 6 hours, starting at midnight, as a test. This job would restart the WiFi interface, which would hopefully resolve the connectivity issue.</p><p>Since the time period between 6AM and 6PM is the primary stretch of time when I would need to access the management interface, having only 4 restarts in a day would be sufficient as a test. If the time outs occurred on a consistently rapid basis, I could then adjust the period between restarts down as needed.</p><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/41/cyber-proj-tfb13.png" alt="OPNSense log showing the WiFi connection failing within an hour of one reboot, then rebooting at noon to restore connectivity." width="1920" height="921" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb13-xs.png 384w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb13-sm.png 600w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb13-md.png 768w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb13-lg.png 1200w, https://korgano.github.io/media/posts/41/responsive/cyber-proj-tfb13-xl.png 1600w"></figure><p>Based on the above log, what is happening is that the "Ethernet detached event" is when the interface loses connectivity for whatever reason, then rebooting the interface updates the configuration to what it should be.</p><p>Maintaining an active (or even semi-active) session seems to prevent the Ethernet detached event, which means even a browser that that's suspended all day might be able to solve the problem.</p><h2 id="mcetoc_1iv5fa9lq1tn">The Next Steps</h2><p>With all the major technical concerns addressed, it's time to stress test the bridge. At least a week and a half of standard network traffic should hopefully be enough to put the bridge and the miniPC through their paces. Once that's done, I'll examine the logs and see if I need to establish new rules to either test detections or block traffic.</p></div><footer class="content__footer"><div class="content__tag-share"><div class="content__tag"><h3 class="content__tag__title">Posted in</h3><ul class="content__tag__list"><li><a href="https://korgano.github.io/tags/cybersecurity/">Cybersecurity</a></li><li><a href="https://korgano.github.io/tags/cybersecurity-projects/">Cybersecurity Projects</a></li><li><a href="https://korgano.github.io/tags/pc/">PC</a></li><li><a href="https://korgano.github.io/tags/tech/">Tech</a></li></ul></div><div class="content__share"><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fkorgano.github.io%2Fcybersecurity-project-transparent-filtering-bridge-extras-80%2F" class="js-share linkedin" aria-label="Share with LinkedIn" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://korgano.github.io/assets/svg/svg-map.svg#linkedin"/></svg></a></div></div></footer></div></article><div class="content__related"><h3 class="content__related__title">Related posts</h3><div class="l-grid l-grid--2"><article class="c-card"><div class="c-card__wrapper"><figure class="c-card__image is-img-loading"><img src="https://korgano.github.io/media/posts/10/glenn-carstens-peters-npxXWgQ33ZQ-unsplash.jpg" srcset="https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-xs.jpg 384w, https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-sm.jpg 600w, https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-md.jpg 768w, https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-lg.jpg 1200w" sizes="(min-width: 37.5em) 80vw, 50vw" loading="lazy" height="2712" width="4076" alt=""></figure><div class="c-card__content"><header><h2 class="c-card__title"><a href="https://korgano.github.io/cybersecurity-project-research-remote-access/" class="invert">Cybersecurity Project Research: Remote Access</a></h2></header><footer class="c-card__meta"><a href="https://korgano.github.io/tags/cybersecurity-projects/" class="c-card__tag">Cybersecurity Projects</a></footer></div></div></article><article class="c-card"><div class="c-card__wrapper"><figure class="c-card__image is-img-loading"><img src="https://korgano.github.io/media/posts/9/andres-urena-vXPXRp_wIg4-unsplash.jpg" srcset="https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-xs.jpg 384w, https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-sm.jpg 600w, https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-md.jpg 768w, https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-lg.jpg 1200w" sizes="(min-width: 37.5em) 80vw, 50vw" loading="lazy" height="1687" width="3000" alt=""></figure><div class="c-card__content"><header><h2 class="c-card__title"><a href="https://korgano.github.io/cybersecurity-headache-home-router-uxui/" class="invert">Cybersecurity Headache: Home Router UXUI</a></h2></header><footer class="c-card__meta"><a href="https://korgano.github.io/tags/quick-thoughts/" class="c-card__tag">Quick Thoughts</a></footer></div></div></article></div></div></main><footer class="footer"><div class="footer__left"><div class="footer__copy">Copyright Xavier Santana, 2023-2024. Powered by Publii.</div></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://korgano.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = { mobileMenuMode: 'sidebar', animationSpeed: 300, submenuWidth: 'auto', doubleClickTime: 500, mobileMenuExpandableSubmenus: true, relatedContainerForOverlayMenuSelector: '.navbar', };</script><script defer="defer" src="https://korgano.github.io/assets/js/scripts.min.js?v=9c5ab7a87221183f149a42b3cceb7956"></script><script>function publiiDetectLoadedImages () {
         var images = document.querySelectorAll('img[loading]:not(.is-loaded)');
         for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
               images[i].classList.add('is-loaded');
               images[i].parentNode.classList.remove('is-img-loading');
            } else {
               images[i].addEventListener('load', function () {
                  this.classList.add('is-loaded');
                  this.parentNode.classList.remove('is-img-loading');
               }, false);
            }
         }
      }
      publiiDetectLoadedImages();</script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-line-numbers.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/clipboard.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-copy-to-clipboard.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-inline-color.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-show-invisibles.min.js"></script><!-- Start main cookie container --><div class="pcb" data-behaviour="badge" data-behaviour-link="#cookie-settings" data-revision="1" data-config-ttl="90" data-debug-mode="false"><!-- Start Banner --><div role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="pcb-title" aria-describedby="pcb-txt" class="pcb__banner"><div class="pcb__inner"><div id="pcb-title" role="heading" aria-level="2" class="pcb__title">This website uses cookies</div><div id="pcb-txt" class="pcb__txt">Select which cookies to opt-in to via the checkboxes below; our website uses cookies to examine site traffic and user activity while on our site, for marketing, and to provide social media functionality. <a href="https://korgano.github.io/privacy-policy/">More details...</a></div><div class="pcb__buttons"><button type="button" class="pcb__btn pcb__btn--solid pcb__btn--accept">Accept all</button></div></div></div><!-- End of Banner --><!-- Badge --> <button class="pcb__badge" aria-label="Cookie Policy" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" width="40" height="40" viewBox="0 0 23 23" fill="currentColor"><path d="M21.41 12.71c-.08-.01-.15 0-.22 0h-.03c-.03 0-.05 0-.08.01-.07 0-.13.01-.19.04-.52.21-1.44.19-2.02-.22-.44-.31-.65-.83-.62-1.53a.758.758 0 0 0-.27-.61.73.73 0 0 0-.65-.14c-1.98.51-3.49.23-4.26-.78-.82-1.08-.73-2.89.24-4.49.14-.23.14-.52 0-.75a.756.756 0 0 0-.67-.36c-.64.03-1.11-.1-1.31-.35-.19-.26-.13-.71-.01-1.29.04-.18.06-.38.03-.59-.05-.4-.4-.7-.81-.66C5.1 1.54 1 6.04 1 11.48 1 17.28 5.75 22 11.6 22c5.02 0 9.39-3.54 10.39-8.42.08-.4-.18-.78-.58-.87Zm-9.81 7.82c-5.03 0-9.12-4.06-9.12-9.06 0-4.34 3.05-8 7.25-8.86-.08.7.05 1.33.42 1.81.24.32.66.67 1.38.84-.76 1.86-.65 3.78.36 5.11.61.81 2.03 2 4.95 1.51.18.96.71 1.54 1.18 1.87.62.43 1.38.62 2.1.62.05 0 .09 0 .13-.01-1.23 3.64-4.7 6.18-8.64 6.18ZM13 17c0 .55-.45 1-1 1s-1-.45-1-1 .45-1 1-1 1 .45 1 1Zm5.29-12.3a.99.99 0 0 1-.29-.71c0-.55.45-.99 1-.99a1 1 0 0 1 .71.3c.19.19.29.44.29.71 0 .55-.45.99-1 .99a1 1 0 0 1-.71-.3ZM9 13.5c0 .83-.67 1.5-1.5 1.5S6 14.33 6 13.5 6.67 12 7.5 12s1.5.67 1.5 1.5Zm3.25.81a.744.744 0 0 1-.06-1.05c.28-.32.75-.34 1.05-.06.31.28.33.75.05 1.06-.15.16-.35.25-.56.25-.18 0-.36-.06-.5-.19ZM8.68 7.26c.41.37.44 1 .07 1.41-.2.22-.47.33-.75.33a.96.96 0 0 1-.67-.26c-.41-.37-.44-1-.07-1.41.37-.42 1-.45 1.41-.08Zm11.48 1.88c.18-.19.52-.19.7 0 .05.04.09.1.11.16.03.06.04.12.04.19 0 .13-.05.26-.15.35-.09.1-.22.15-.35.15s-.26-.05-.35-.15a.355.355 0 0 1-.11-.16.433.433 0 0 1-.04-.19c0-.13.05-.26.15-.35Zm-4.93-1.86a.75.75 0 1 1 1.059-1.06.75.75 0 0 1-1.059 1.06Z"/></svg></button><!-- End of Badge --></div><!-- End of main cookie container --><script>(function(win) {
    if (!document.querySelector('.pcb')) {
        return;
    }

    var cbConfig = {
        behaviour: document.querySelector('.pcb').getAttribute('data-behaviour'),
        behaviourLink: document.querySelector('.pcb').getAttribute('data-behaviour-link'),
        revision: document.querySelector('.pcb').getAttribute('data-revision'),
        configTTL: parseInt(document.querySelector('.pcb').getAttribute('data-config-ttl'), 10),
        debugMode: document.querySelector('.pcb').getAttribute('data-debug-mode') === 'true',
        initialState: null,
        initialLsState: null,
        previouslyAccepted: []
    };

    var cbUI = {
        wrapper: document.querySelector('.pcb'),
        banner: {
            element: null,
            btnAccept: null,
            btnReject: null,
            btnConfigure: null
        },
        popup: {
            element: null,
            btnClose: null,
            btnSave: null,
            btnAccept: null,
            btnReject: null,
            checkboxes: null,
        },
        overlay: null,
        badge: null,
        blockedScripts: document.querySelectorAll('script[type^="gdpr-blocker/"]'),
        triggerLinks: cbConfig.behaviourLink ? document.querySelectorAll('a[href*="' + cbConfig.behaviourLink + '"]') : null
    };

    function initUI () {
        // setup banner elements
        cbUI.banner.element = cbUI.wrapper.querySelector('.pcb__banner');
        cbUI.banner.btnAccept = cbUI.banner.element.querySelector('.pcb__btn--accept');
        cbUI.banner.btnReject = cbUI.banner.element.querySelector('.pcb__btn--reject');
        cbUI.banner.btnConfigure = cbUI.banner.element.querySelector('.pcb__btn--configure');

        // setup popup elements
        if (cbUI.wrapper.querySelector('.pcb__popup')) {
            cbUI.popup.element = cbUI.wrapper.querySelector('.pcb__popup');
            cbUI.popup.btnClose = cbUI.wrapper.querySelector('.pcb__popup__close');
            cbUI.popup.btnSave = cbUI.popup.element.querySelector('.pcb__btn--save');
            cbUI.popup.btnAccept = cbUI.popup.element.querySelector('.pcb__btn--accept');
            cbUI.popup.btnReject = cbUI.popup.element.querySelector('.pcb__btn--reject');
            cbUI.popup.checkboxes = cbUI.popup.element.querySelector('input[type="checkbox"]');
            // setup overlay
            cbUI.overlay = cbUI.wrapper.querySelector('.pcb__overlay');
        }

        cbUI.badge = cbUI.wrapper.querySelector('.pcb__badge');

        if (cbConfig.behaviour.indexOf('link') > -1) {
            for (var i = 0; i < cbUI.triggerLinks.length; i++) {
                cbUI.triggerLinks[i].addEventListener('click', function(e) {
                    e.preventDefault();
                    showBannerOrPopup();
                });
            }
        }
    }

    function initState () {
        var lsKeyName = getConfigName();
        var currentConfig = localStorage.getItem(lsKeyName);
        var configIsFresh = checkIfConfigIsFresh();

        if (!configIsFresh || currentConfig === null) {
            if (cbConfig.debugMode) {
                console.log('ðŸª Config not found, or configuration expired');
            }

            if (window.publiiCBGCM) {
                gtag('consent', 'default', {
                    'ad_storage': window.publiiCBGCM.defaultState.ad_storage ? 'granted' : 'denied',
                    'ad_personalization': window.publiiCBGCM.defaultState.ad_personalization ? 'granted' : 'denied',
                    'ad_user_data': window.publiiCBGCM.defaultState.ad_user_data ? 'granted' : 'denied',
                    'analytics_storage': window.publiiCBGCM.defaultState.analytics_storage ? 'granted' : 'denied',
                    'personalization_storage': window.publiiCBGCM.defaultState.personalization_storage ? 'granted' : 'denied',
                    'functionality_storage': window.publiiCBGCM.defaultState.functionality_storage ? 'granted' : 'denied',
                    'security_storage': window.publiiCBGCM.defaultState.security_storage ? 'granted' : 'denied'
                });  
                
                if (cbConfig.debugMode) {
                    console.log('ðŸª GCMv2 DEFAULT STATE: ' + JSON.stringify({
                        'ad_storage': window.publiiCBGCM.defaultState.ad_storage ? 'granted' : 'denied',
                        'ad_personalization': window.publiiCBGCM.defaultState.ad_personalization ? 'granted' : 'denied',
                        'ad_user_data': window.publiiCBGCM.defaultState.ad_user_data ? 'granted' : 'denied',
                        'analytics_storage': window.publiiCBGCM.defaultState.analytics_storage ? 'granted' : 'denied',
                        'personalization_storage': window.publiiCBGCM.defaultState.personalization_storage ? 'granted' : 'denied',
                        'functionality_storage': window.publiiCBGCM.defaultState.functionality_storage ? 'granted' : 'denied',
                        'security_storage': window.publiiCBGCM.defaultState.security_storage ? 'granted' : 'denied'
                    }));
                }
            }

            showBanner();
        } else if (typeof currentConfig === 'string') {
            if (cbConfig.debugMode) {
                console.log('ðŸª Config founded');
            }

            cbConfig.initialLsState = currentConfig.split(',');

            if (window.publiiCBGCM) {
                gtag('consent', 'default', {
                    'ad_storage': getDefaultConsentState(currentConfig, 'ad_storage'),
                    'ad_personalization': getDefaultConsentState(currentConfig, 'ad_personalization'),
                    'ad_user_data': getDefaultConsentState(currentConfig, 'ad_user_data'),
                    'analytics_storage': getDefaultConsentState(currentConfig, 'analytics_storage'),
                    'personalization_storage': getDefaultConsentState(currentConfig, 'personalization_storage'),
                    'functionality_storage': getDefaultConsentState(currentConfig, 'functionality_storage'),
                    'security_storage': getDefaultConsentState(currentConfig, 'security_storage')
                });
                
                if (cbConfig.debugMode) {
                    console.log('ðŸª GCMv2 DEFAULT STATE: ' + JSON.stringify({
                        'ad_storage': getDefaultConsentState(currentConfig, 'ad_storage'),
                        'ad_personalization': getDefaultConsentState(currentConfig, 'ad_personalization'),
                        'ad_user_data': getDefaultConsentState(currentConfig, 'ad_user_data'),
                        'analytics_storage': getDefaultConsentState(currentConfig, 'analytics_storage'),
                        'personalization_storage': getDefaultConsentState(currentConfig, 'personalization_storage'),
                        'functionality_storage': getDefaultConsentState(currentConfig, 'functionality_storage'),
                        'security_storage': getDefaultConsentState(currentConfig, 'security_storage')
                    }));
                }
            }

            showBadge();

            if (cbUI.popup.element) {
                var allowedGroups = currentConfig.split(',');
                var checkedCheckboxes = cbUI.popup.element.querySelectorAll('input[type="checkbox"]:checked');

                for (var j = 0; j < checkedCheckboxes.length; j++) {
                    var name = checkedCheckboxes[j].getAttribute('data-group-name');

                    if (name && name !== '-' && allowedGroups.indexOf(name) === -1) {
                        checkedCheckboxes[j].checked = false;
                    }
                }

                for (var i = 0; i < allowedGroups.length; i++) {
                    var checkbox = cbUI.popup.element.querySelector('input[type="checkbox"][data-group-name="' + allowedGroups[i] + '"]');

                    if (checkbox) {
                        checkbox.checked = true;
                    }

                    allowCookieGroup(allowedGroups[i]);
                }
            }
        }

        setTimeout(function () {
            cbConfig.initialState = getInitialStateOfConsents();
        }, 0);
    }

    function checkIfConfigIsFresh () {
        var lastConfigSave = localStorage.getItem('publii-gdpr-cookies-config-save-date');

        if (lastConfigSave === null) {
            return false;
        }

        lastConfigSave = parseInt(lastConfigSave, 10);

        if (lastConfigSave === 0) {
            return true;
        }

        if (+new Date() - lastConfigSave < cbConfig.configTTL * 24 * 60 * 60 * 1000) {
            return true;
        }

        return false;
    }

    function getDefaultConsentState (currentConfig, consentGroup) {
        let configGroups = currentConfig.split(',');

        for (let i = 0; i < configGroups.length; i++) {
            let groupName = configGroups[i];
            let group = window.publiiCBGCM.groups.find(group => group.cookieGroup === groupName);

            if (group && group[consentGroup]) {
                return 'granted';
            }
        }  
        
        if (window.publiiCBGCM.defaultState[consentGroup]) {
            return 'granted'; 
        }
        
        return 'denied';
    }

    function initBannerEvents () {
        cbUI.banner.btnAccept.addEventListener('click', function (e) {
            e.preventDefault();
            acceptAllCookies('banner');
            showBadge();
        }, false);

        if (cbUI.banner.btnReject) {
            cbUI.banner.btnReject.addEventListener('click', function (e) {
                e.preventDefault();
                rejectAllCookies();
                showBadge();
            }, false);
        }

        if (cbUI.banner.btnConfigure) {
            cbUI.banner.btnConfigure.addEventListener('click', function (e) {
                e.preventDefault();
                hideBanner();
                showAdvancedPopup();
                showBadge();
            }, false);
        }
    }

    function initPopupEvents () {
        if (!cbUI.popup.element) {
            return;
        }

        cbUI.overlay.addEventListener('click', function (e) {
            hideAdvancedPopup();
        }, false);

        cbUI.popup.element.addEventListener('click', function (e) {
            e.stopPropagation();
        }, false);

        cbUI.popup.btnAccept.addEventListener('click', function (e) {
            e.preventDefault();
            acceptAllCookies('popup');
        }, false);

        cbUI.popup.btnReject.addEventListener('click', function (e) {
            e.preventDefault();
            rejectAllCookies();
        }, false);

        cbUI.popup.btnSave.addEventListener('click', function (e) {
            e.preventDefault();
            saveConfiguration();
        }, false);

        cbUI.popup.btnClose.addEventListener('click', function (e) {
            e.preventDefault();
            hideAdvancedPopup();
        }, false);
    }

    function initBadgeEvents () {
        if (!cbUI.badge) {
            return;
        }

        cbUI.badge.addEventListener('click', function (e) {
            showBannerOrPopup();
        }, false);
    }

    initUI();
    initState();
    initBannerEvents();
    initPopupEvents();
    initBadgeEvents();

    /**
     * API
     */
    function addScript (src, inline) {
        var newScript = document.createElement('script');

        if (src) {
            newScript.setAttribute('src', src);
        }

        if (inline) {
            newScript.text = inline;
        }

        document.body.appendChild(newScript);
    }

    function allowCookieGroup (allowedGroup) {
        var scripts = document.querySelectorAll('script[type="gdpr-blocker/' + allowedGroup + '"]');
        cbConfig.previouslyAccepted.push(allowedGroup);
    
        for (var j = 0; j < scripts.length; j++) {
            addScript(scripts[j].src, scripts[j].text);
        }

        var groupEvent = new Event('publii-cookie-banner-unblock-' + allowedGroup);
        document.body.dispatchEvent(groupEvent);
        unlockEmbeds(allowedGroup);

        if (cbConfig.debugMode) {
            console.log('ðŸª Allowed group: ' + allowedGroup);
        }

        if (window.publiiCBGCM && (!cbConfig.initialLsState || cbConfig.initialLsState.indexOf(allowedGroup) === -1)) {
            let consentResult = {};
            let group = window.publiiCBGCM.groups.find(group => group.cookieGroup === allowedGroup);

            if (group) {
                let foundSomeConsents = false;

                Object.keys(group).forEach(key => {
                    if (key !== 'cookieGroup' && group[key] === true) {
                        consentResult[key] = 'granted';
                        foundSomeConsents = true;
                    }
                });

                if (foundSomeConsents) {
                    gtag('consent', 'update', consentResult);   

                    if (cbConfig.debugMode) {
                        console.log('ðŸª GCMv2 UPDATE: ' + JSON.stringify(consentResult));
                    }
                }
            }
        }
    }

    function showBannerOrPopup () {
        if (cbUI.popup.element) {
            showAdvancedPopup();
        } else {
            showBanner();
        }
    }

    function showAdvancedPopup () {
        cbUI.popup.element.classList.add('is-visible');
        cbUI.overlay.classList.add('is-visible');
        cbUI.popup.element.setAttribute('aria-hidden', 'false');
        cbUI.overlay.setAttribute('aria-hidden', 'false');
    }

    function hideAdvancedPopup () {
        cbUI.popup.element.classList.remove('is-visible');
        cbUI.overlay.classList.remove('is-visible');
        cbUI.popup.element.setAttribute('aria-hidden', 'true');
        cbUI.overlay.setAttribute('aria-hidden', 'true');
    }

    function showBanner () {
        cbUI.banner.element.classList.add('is-visible');
        cbUI.banner.element.setAttribute('aria-hidden', 'false');
    }

    function hideBanner () {
        cbUI.banner.element.classList.remove('is-visible');
        cbUI.banner.element.setAttribute('aria-hidden', 'true');
    }

    function showBadge () {
        if (!cbUI.badge) {
            return;
        }

        cbUI.badge.classList.add('is-visible');
        cbUI.badge.setAttribute('aria-hidden', 'false');
    }

    function getConfigName () {
        var lsKeyName = 'publii-gdpr-allowed-cookies';

        if (cbConfig.revision) {
            lsKeyName = lsKeyName + '-v' + parseInt(cbConfig.revision, 10);
        }

        return lsKeyName;
    }

    function storeConfiguration (allowedGroups) {
        var lsKeyName = getConfigName();
        var dataToStore = allowedGroups.join(',');
        localStorage.setItem(lsKeyName, dataToStore);

        if (cbConfig.configTTL === 0) {
            localStorage.setItem('publii-gdpr-cookies-config-save-date', 0);

            if (cbConfig.debugMode) {
                console.log('ðŸª Store never expiring configuration');
            }
        } else {
            localStorage.setItem('publii-gdpr-cookies-config-save-date', +new Date());
        }
    }

    function getInitialStateOfConsents () {
        if (!cbUI.popup.element) {
            return [];
        }

        var checkedGroups = cbUI.popup.element.querySelectorAll('input[type="checkbox"]:checked');
        var groups = [];

        for (var i = 0; i < checkedGroups.length; i++) {
            var allowedGroup = checkedGroups[i].getAttribute('data-group-name');

            if (allowedGroup !== '') {
                groups.push(allowedGroup);
            }
        }

        if (cbConfig.debugMode) {
            console.log('ðŸª Initial state: ' + groups.join(', '));
        }

        return groups;
    }

    function getCurrentStateOfConsents () {
        if (!cbUI.popup.element) {
            return [];
        }

        var checkedGroups = cbUI.popup.element.querySelectorAll('input[type="checkbox"]:checked');
        var groups = [];

        for (var i = 0; i < checkedGroups.length; i++) {
            var allowedGroup = checkedGroups[i].getAttribute('data-group-name');

            if (allowedGroup !== '') {
                groups.push(allowedGroup);
            }
        }

        if (cbConfig.debugMode) {
            console.log('ðŸª State to save: ' + groups.join(', '));
        }

        return groups;
    }

    function getAllGroups () {
        if (!cbUI.popup.element) {
            return [];
        }

        var checkedGroups = cbUI.popup.element.querySelectorAll('input[type="checkbox"]');
        var groups = [];

        for (var i = 0; i < checkedGroups.length; i++) {
            var allowedGroup = checkedGroups[i].getAttribute('data-group-name');

            if (allowedGroup !== '') {
                groups.push(allowedGroup);
            }
        }

        return groups;
    }

    function acceptAllCookies (source) {
        var groupsToAccept = getAllGroups();
        storeConfiguration(groupsToAccept);

        for (var i = 0; i < groupsToAccept.length; i++) {
            var group = groupsToAccept[i];

            if (cbConfig.initialState.indexOf(group) > -1 || cbConfig.previouslyAccepted.indexOf(group) > -1) {
                if (cbConfig.debugMode) {
                    console.log('ðŸª Skip previously activated group: ' + group);
                }

                continue;
            }

            allowCookieGroup(group);
        }

        if (cbUI.popup.element) {
            var checkboxesToCheck = cbUI.popup.element.querySelectorAll('input[type="checkbox"]');

            for (var j = 0; j < checkboxesToCheck.length; j++) {
                checkboxesToCheck[j].checked = true;
            }
        }

        if (cbConfig.debugMode) {
            console.log('ðŸª Accept all cookies: ', groupsToAccept.join(', '));
        }

        if (source === 'popup') {
            hideAdvancedPopup();
        } else if (source === 'banner') {
            hideBanner();
        }
    }

    function rejectAllCookies () {
        if (cbConfig.debugMode) {
            console.log('ðŸª Reject all cookies');
        }

        storeConfiguration([]);
        setTimeout(function () {
            window.location.reload();
        }, 100);
    }

    function saveConfiguration () {
        var groupsToAccept = getCurrentStateOfConsents();
        storeConfiguration(groupsToAccept);

        if (cbConfig.debugMode) {
            console.log('ðŸª Save new config: ', groupsToAccept.join(', '));
        }

        if (reloadIsNeeded(groupsToAccept)) {
            setTimeout(function () {
                window.location.reload();
            }, 100);
            return;
        }

        for (var i = 0; i < groupsToAccept.length; i++) {
            var group = groupsToAccept[i];

            if (cbConfig.initialState.indexOf(group) > -1 || cbConfig.previouslyAccepted.indexOf(group) > -1) {
                if (cbConfig.debugMode) {
                    console.log('ðŸª Skip previously activated group: ' + group);
                }

                continue;
            }

            allowCookieGroup(group);
        }

        hideAdvancedPopup();
    }

    function reloadIsNeeded (groupsToAccept) {
        // check if user rejected consent for initial groups
        var initialGroups = cbConfig.initialState;
        var previouslyAcceptedGroups = cbConfig.previouslyAccepted;
        var groupsToCheck = initialGroups.concat(previouslyAcceptedGroups);

        for (var i = 0; i < groupsToCheck.length; i++) {
            var groupToCheck = groupsToCheck[i];

            if (groupToCheck !== '' && groupsToAccept.indexOf(groupToCheck) === -1) {
                if (cbConfig.debugMode) {
                    console.log('ðŸª Reload is needed due lack of: ', groupToCheck);
                }

                return true;
            }
        }

        return false;
    }

    function unlockEmbeds (cookieGroup) {
        var iframesToUnlock = document.querySelectorAll('.pec-wrapper[data-consent-group-id="' + cookieGroup + '"]');

        for (var i = 0; i < iframesToUnlock.length; i++) {
            var iframeWrapper = iframesToUnlock[i];
            iframeWrapper.querySelector('.pec-overlay').classList.remove('is-active');
            iframeWrapper.querySelector('.pec-overlay').setAttribute('aria-hidden', 'true');
            var iframe = iframeWrapper.querySelector('iframe');
            iframe.setAttribute('src', iframe.getAttribute('data-consent-src'));
        }
    }

    win.publiiEmbedConsentGiven = function (cookieGroup) {
        // it will unlock embeds
        allowCookieGroup(cookieGroup);

        var checkbox = cbUI.popup.element.querySelector('input[type="checkbox"][data-group-name="' + cookieGroup + '"]');

        if (checkbox) {
            checkbox.checked = true;
        }

        var groupsToAccept = getCurrentStateOfConsents();
        storeConfiguration(groupsToAccept);

        if (cbConfig.debugMode) {
            console.log('ðŸª Save new config: ', groupsToAccept.join(', '));
        }
    }
})(window);</script></body></html>