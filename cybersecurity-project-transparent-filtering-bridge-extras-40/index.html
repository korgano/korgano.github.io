<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 4.0 - XS Tech Thoughts</title><meta name="description" content="%pagetitle: Cybersecurity practioner experiments with using AI to generate rules for Suricata Intrusion Prevention System."><meta name="generator" content="Publii Open-Source CMS for Static Site"><!-- Global site tag (gtag.js) - Google Analytics --><script type="gdpr-blocker/Analytics" async src="https://www.googletagmanager.com/gtag/js?id=G-EHLH28GQMY"></script><script type="gdpr-blocker/Analytics">window.dataLayer = window.dataLayer || [];
				  function gtag(){dataLayer.push(arguments);}
				  gtag('js', new Date());
				  gtag('config', 'G-EHLH28GQMY' , { 'anonymize_ip': true });
				  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EHLH28GQMY"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EHLH28GQMY');</script><link rel="stylesheet" href="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-black.css"><link rel="stylesheet" href="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-inline-color.css"><link rel="canonical" href="https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-40/"><link rel="alternate" type="application/atom+xml" href="https://korgano.github.io/feed.xml" title="XS Tech Thoughts - RSS"><meta property="og:title" content="CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 4.0"><meta property="og:image" content="https://korgano.github.io/media/posts/23/cyber-proj-tfb06-2.png"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="912"><meta property="og:site_name" content="XS Tech Thoughts"><meta property="og:description" content="%pagetitle: Cybersecurity practioner experiments with using AI to generate rules for Suricata Intrusion Prevention System."><meta property="og:url" content="https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-40/"><meta property="og:type" content="article"><link rel="preload" href="https://korgano.github.io/assets/dynamic/fonts/robotoflex/robotoflex.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://korgano.github.io/assets/dynamic/fonts/robotoslab/robotoslab.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://korgano.github.io/assets/css/style.css?v=253922ed3c1816ffff870ea807b853dd"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-40/"},"headline":"CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 4.0","datePublished":"2024-09-06T10:19-04:00","dateModified":"2024-09-26T10:19-04:00","image":{"@type":"ImageObject","url":"https://korgano.github.io/media/posts/23/cyber-proj-tfb06-2.png","height":912,"width":1920},"description":"%pagetitle: Cybersecurity practioner experiments with using AI to generate rules for Suricata Intrusion Prevention System.","author":{"@type":"Person","name":"Xavier Santana","url":"https://korgano.github.io/authors/xavier-santana/"},"publisher":{"@type":"Organization","name":"Xavier Santana"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template lines"><div class="container lines lines--right"><header class="header"><a href="https://korgano.github.io/" class="logo">XS Tech Thoughts</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu">Menu</button><ul class="navbar__menu"><li><a href="https://korgano.github.io/" title="Home" target="_self">Home</a></li><li><a href="https://korgano.github.io/tags/uxui-case-study/" title="UX/UI Case Studies" target="_blank">UX/UI Case Studies</a></li><li><a href="https://korgano.github.io/tags/cybersecurity-projects/" title="Cybersecurity Projects" target="_blank">Cybersecurity Projects</a></li><li><a href="https://korgano.github.io/tags/quick-thoughts/" title="Quick Thoughts" target="_self">Quick Thoughts</a></li><li><a href="https://korgano.github.io/about-me/" title="About Me" target="_blank">About Me</a></li></ul></nav></header><main class="main post"><article class="content"><header class="content__inner content__header"><h1 class="content__title">CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 4.0</h1><div class="content__meta"><div class="content__meta__left"><a href="https://korgano.github.io/authors/xavier-santana/" class="invert content__author" rel="author" title="Xavier Santana">Xavier Santana</a></div><div class="content__meta__right"><time datetime="2024-09-06T10:19" class="content__date">September 6, 2024</time><div class="content__updated">Updated on <time datetime="2024-09-06T10:19" class="content__date">September 26, 2024</time></div></div></div></header><figure class="content__featured-image"><div class="content__featured-image__inner is-img-loading"><img src="https://korgano.github.io/media/posts/23/cyber-proj-tfb06-2.png" srcset="https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-2-xs.png 384w, https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-2-sm.png 600w, https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-2-md.png 768w, https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-2-lg.png 1200w, https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-2-xl.png 1600w" sizes="(min-width: 37.5em) 1600px, 80vw" loading="eager" height="912" width="1920" alt="ThriveDX login error screen"></div></figure><div class="content__inner"><div class="content__entry"><p><a href="https://korgano.github.io/quick-cyber-thoughts-more-reasons-for-local-ai/" title="Quick Cyber Thoughts: More Reasons for Local AI" target="_blank" rel="noopener noreferrer">After a brief delay caused by ChatGPT session cookies being corrupted</a>, we're getting back on track with the Transparent Filtering Bridge project.</p><p>This week, we're going to try to make Suricata IPS rules with AI, namely ChatGPT (whatever model free users get to use as 9/25/2024) and Bing Copilot. (As as aside, it's kind of annoying that ChatGPT sometimes lets free users have access to higher quality models, but doesn't explicitly notify the user which model is being used.)</p><p>Since Suricata caused the OPNsense install to crash (<a href="https://github.com/opnsense/core/pull/7857/commits/6ba73f76afeff585cb6b1eeab49c08ae3026229b" title="OPNsense/Core Pull Request - Reduce pointless logging" target="_blank" rel="noopener noreferrer">possibly because someone set the default stat logging to <strong>8 seconds</strong></a>), we can't test in OPNsense itself. But I still retain ThriveDX access, so let's see if I can get the rules to run on one of their VMs running Suricata. (This is far from certain, given how janky their VMs/internet connections are.)</p><h2>The Prompts</h2><p>As before, the first step of the test is to come up with two prompts to feed into both AI.</p><p>Why two? Well, the first is going to be a simple directory traversal detector, looking for <code>../</code> or  <span class="fontstyle0"><code>%2e%2e%2f</code>:</span></p><blockquote><p>Make me a Suricata IPS rule that does the following:</p><ul><li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Detects incoming connections containing ../ or </span><span class="fontstyle0" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">%2e%2e%2f.</span></li><li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Blocks the connection.</span></li><li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Generates a log stating "Detected directory traversal attempt from &lt;source IP&gt; to &lt;destination IP&gt; at &lt;time&gt;".</span></li></ul></blockquote><p>The second is going to be more complex and based on a <a href="https://documents.trendmicro.com/assets/white_papers/wp-tracking-the-activities-of-teamTNT.pdf" title="Tracking the Activities of TeamTNT: A Closer Look at a Cloud-Focused Malicious Actor Group" target="_blank" rel="noopener noreferrer">TrendMicro report on TeamTNT's credential theft techniques</a>:</p><blockquote><p>Make me a Suricata IPS rule that does the following:</p><ul><li>Detects incoming connections containing "userfile=@/etc/passwd" or "userfile=@/etc/hosts".</li><li>Blocks the connection.</li><li>Generates a log stating "Blocked potential SSH credential theft attack from &lt;source IP&gt; on &lt;destination IP&gt; at &lt;time&gt;."</li></ul></blockquote><p>(Annoyingly, there are no Indicators of Compromise (IoTs) or code examples for the recently revealed Ryzen vulnerability, which was something I wanted to craft rules for.)</p><h2>ChatGPT - Prompt 1</h2><p>Here's what ChatGPT generated:</p><blockquote><h3>Steps:</h3><ol><li><p><strong>Create the rule:</strong></p><ul><li>Suricata rules generally follow this structure:</li><li><code>action protocol src_ip src_port direction dst_ip dst_port (rule_options;)</code></li><li>For your case, you'll use <strong><code>alert</code></strong> action (to generate a log) combined with <strong><code>drop</code></strong> action (to block the connection).</li><li>We'll detect <strong><code>../</code></strong> and <strong><code>%2e%2e%2f</code></strong> in the URI.</li></ul></li><li><p><strong>Rule Components:</strong></p><ul><li><strong>alert</strong> and <strong>drop</strong>: Both will be used to detect and block.</li><li><strong>http_uri</strong>: To inspect the HTTP request URI.</li><li><strong>content</strong>: To look for specific strings (<code>../</code> or <code>%2e%2e%2f</code>).</li><li><strong>msg</strong>: To specify a custom log message.</li><li><strong>sid</strong>: Rule identifier (must be unique).</li><li><strong>flow</strong>: Specifies the direction (from the client to the server).</li><li><strong>metadata</strong>: Includes information about the rule type (IPS) and severity.</li><li><strong>logto</strong>: To specify log output.</li></ul></li><li><p><strong>Example Suricata Rule</strong>:</p><ol><li><code>alert http any any -&gt; any any (msg:"Detected directory traversal attempt from &lt;source IP&gt; to &lt;destination IP&gt; at &lt;time&gt;"; content:"../"; http_uri; nocase; sid:1000001; rev:1; logto:"traversal.log";)</code></li><li><code>alert http any any -&gt; any any (msg:"Detected directory traversal attempt from &lt;source IP&gt; to &lt;destination IP&gt; at &lt;time&gt;"; content:"%2e%2e%2f"; http_uri; nocase; sid:1000002; rev:1; logto:"traversal.log";)</code></li><li><code></code><code>drop http any any -&gt; any any (msg:"Blocked directory traversal attempt"; content:"../"; http_uri; nocase; sid:1000003; rev:1;)</code></li><li><code></code><code>drop http any any -&gt; any any (msg:"Blocked directory traversal attempt"; content:"%2e%2e%2f"; http_uri; nocase; sid:1000004; rev:1;)</code></li></ol></li></ol></blockquote><h2>Bing Copilot - Prompt 1</h2><p>Here's Bing Copilot's output:</p><blockquote><div class="content user-select-text" tabindex="0" aria-description="" aria-label="Sent by Copilot: Sure! Here's a Suricata IPS rule that meets your requirements:

&#96;&#96;&#96;yaml
alert http any any -&gt; any any (msg:&quot;Detected directory traversal attempt from &lt;source IP&gt; to &lt;destination IP&gt; at &lt;time&gt;&quot;; content:&quot;../&quot;; nocase; http_uri; sid:1000001; rev:1;)
alert http any any -&gt; any any (msg:&quot;Detected directory traversal attempt from &lt;source IP&gt; to &lt;destination IP&gt; at &lt;time&gt;&quot;; content:&quot;%2e%2e%2f&quot;; nocase; http_uri; sid:1000002; rev:1;)
drop http any any -&gt; any any (msg:&quot;Blocking directory traversal attempt&quot;; content:&quot;../&quot;; nocase; http_uri; sid:1000003; rev:1;)
drop http any any -&gt; any any (msg:&quot;Blocking directory traversal attempt&quot;; content:&quot;%2e%2e%2f&quot;; nocase; http_uri; sid:1000004; rev:1;)
&#96;&#96;&#96;

This rule does the following:
1. **Detects incoming connections** containing &#96;../&#96; or &#96;%2e%2e%2f&#96;.
2. **Blocks the connection** if such patterns are detected.
3. **Generates a log** with the message &quot;Detected directory traversal attempt from &lt;source IP&gt; to &lt;destination IP&gt; at &lt;time&gt;&quot;.

Feel free to adjust the &#96;sid&#96; (Signature ID) and &#96;rev&#96; (Revision) numbers as needed. Let me know if you need any further customization!"><div class="ac-container ac-adaptiveCard has-image"><div class="ac-textBlock"><p>Sure! Here’s a Suricata IPS rule that meets your requirements:</p><pre><code class="language-yaml"><span class="hljs-string">alert</span> <span class="hljs-string">http</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">(msg:"Detected</span> <span class="hljs-string">directory</span> <span class="hljs-string">traversal</span> <span class="hljs-string">attempt</span> <span class="hljs-string">from</span> <span class="hljs-string">&lt;source</span> <span class="hljs-string">IP&gt;</span> <span class="hljs-string">to</span> <span class="hljs-string">&lt;destination</span> <span class="hljs-string">IP&gt;</span> <span class="hljs-string">at</span> <span class="hljs-string">&lt;time&gt;";</span> <span class="hljs-string">content:"../";</span> <span class="hljs-string">nocase;</span> <span class="hljs-string">http_uri;</span> <span class="hljs-string">sid:1000001;</span> <span class="hljs-string">rev:1;)</span>
<span class="hljs-string">alert</span> <span class="hljs-string">http</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">(msg:"Detected</span> <span class="hljs-string">directory</span> <span class="hljs-string">traversal</span> <span class="hljs-string">attempt</span> <span class="hljs-string">from</span> <span class="hljs-string">&lt;source</span> <span class="hljs-string">IP&gt;</span> <span class="hljs-string">to</span> <span class="hljs-string">&lt;destination</span> <span class="hljs-string">IP&gt;</span> <span class="hljs-string">at</span> <span class="hljs-string">&lt;time&gt;";</span> <span class="hljs-string">content:"%2e%2e%2f";</span> <span class="hljs-string">nocase;</span> <span class="hljs-string">http_uri;</span> <span class="hljs-string">sid:1000002;</span> <span class="hljs-string">rev:1;)</span>
<span class="hljs-string">drop</span> <span class="hljs-string">http</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">(msg:"Blocking</span> <span class="hljs-string">directory</span> <span class="hljs-string">traversal</span> <span class="hljs-string">attempt";</span> <span class="hljs-string">content:"../";</span> <span class="hljs-string">nocase;</span> <span class="hljs-string">http_uri;</span> <span class="hljs-string">sid:1000003;</span> <span class="hljs-string">rev:1;)</span>
<span class="hljs-string">drop</span> <span class="hljs-string">http</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">(msg:"Blocking</span> <span class="hljs-string">directory</span> <span class="hljs-string">traversal</span> <span class="hljs-string">attempt";</span> <span class="hljs-string">content:"%2e%2e%2f";</span> <span class="hljs-string">nocase;</span> <span class="hljs-string">http_uri;</span> <span class="hljs-string">sid:1000004;</span> <span class="hljs-string">rev:1;)</span>
</code></pre><p>This rule does the following:</p><ol><li><strong>Detects incoming connections</strong> containing <code>../</code> or <code>%2e%2e%2f</code>.</li><li><strong>Blocks the connection</strong> if such patterns are detected.</li><li><strong>Generates a log</strong> with the message “Detected directory traversal attempt from &lt;source IP&gt; to &lt;destination IP&gt; at &lt;time&gt;”.</li></ol><p>Feel free to adjust the <code>sid</code> (Signature ID) and <code>rev</code> (Revision) numbers as needed. Let me know if you need any further customization!</p></div></div></div></blockquote><h2>ChatGPT - Prompt 2</h2><p>Now we move onto the second prompt:</p><blockquote><h3>Steps:</h3><ol><li><p><strong>Understand the context</strong>:</p><ul><li>We need to detect <strong>specific strings</strong> that might indicate a file inclusion attack.</li><li>The rule will look for these strings in the <strong>HTTP request body or URL parameters</strong>.</li><li>Suricata will generate a log and block the connection.</li></ul></li><li><p><strong>Rule Structure</strong>:</p><ul><li>Use <strong><code>alert</code></strong> (to generate logs) and <strong><code>drop</code></strong> (to block the connection).</li><li>Detect the strings <strong><code>userfile=@/etc/passwd</code></strong> and <strong><code>userfile=@/etc/hosts</code></strong>.</li><li>Use the <strong><code>content</code></strong> option for string matching, <strong><code>http_client_body</code></strong> for detecting the attack within the HTTP request, and <strong><code>nocase</code></strong> to make it case-insensitive.</li></ul></li><li><p><strong>Example Suricata Rules</strong>:</p></li><li><code>alert http any any -&gt; any any (msg:"Blocked potential SSH credential theft attack from &lt;source IP&gt; on &lt;destination IP&gt; at &lt;time&gt;"; content:"userfile=@/etc/passwd"; http_client_body; nocase; sid:2000001; rev:1;)</code></li><li><code>alert http any any -&gt; any any (msg:"Blocked potential SSH credential theft attack from &lt;source IP&gt; on &lt;destination IP&gt; at &lt;time&gt;"; content:"userfile=@/etc/hosts"; http_client_body; nocase; sid:2000002; rev:1;)</code></li><li><code>drop http any any -&gt; any any (msg:"Blocked potential SSH credential theft attack from &lt;source IP&gt; on &lt;destination IP&gt; at &lt;time&gt;"; content:"userfile=@/etc/passwd"; http_client_body; nocase; sid:2000003; rev:1;)</code></li><li><code>drop http any any -&gt; any any (msg:"Blocked potential SSH credential theft attack from &lt;source IP&gt; on &lt;destination IP&gt; at &lt;time&gt;"; content:"userfile=@/etc/hosts"; http_client_body; nocase; sid:2000004; rev:1;)</code></li></ol></blockquote><h2>Bing Copilot - Prompt 2</h2><p>Now we move to Bing Copilot:</p><blockquote><div class="content user-select-text" tabindex="0" aria-description="" aria-label="Sent by Copilot: Here's a Suricata IPS rule that meets your requirements:

&#96;&#96;&#96;yaml
alert http any any -&gt; any any (msg:&quot;Blocked potential SSH credential theft attack from &lt;source IP&gt; on &lt;destination IP&gt; at &lt;time&gt;&quot;; content:&quot;userfile=@/etc/passwd&quot;; nocase; http_uri; sid:1000005; rev:1;)
alert http any any -&gt; any any (msg:&quot;Blocked potential SSH credential theft attack from &lt;source IP&gt; on &lt;destination IP&gt; at &lt;time&gt;&quot;; content:&quot;userfile=@/etc/hosts&quot;; nocase; http_uri; sid:1000006; rev:1;)
drop http any any -&gt; any any (msg:&quot;Blocking potential SSH credential theft attack&quot;; content:&quot;userfile=@/etc/passwd&quot;; nocase; http_uri; sid:1000007; rev:1;)
drop http any any -&gt; any any (msg:&quot;Blocking potential SSH credential theft attack&quot;; content:&quot;userfile=@/etc/hosts&quot;; nocase; http_uri; sid:1000008; rev:1;)
&#96;&#96;&#96;

This rule does the following:
1. **Detects incoming connections** containing &quot;userfile=@/etc/passwd&quot; or &quot;userfile=@/etc/hosts&quot;.
2. **Blocks the connection** if such patterns are detected.
3. **Generates a log** with the message &quot;Blocked potential SSH credential theft attack from &lt;source IP&gt; on &lt;destination IP&gt; at &lt;time&gt;&quot;.

Feel free to adjust the &#96;sid&#96; (Signature ID) and &#96;rev&#96; (Revision) numbers as needed. Let me know if you need any further customization!"><div class="ac-container ac-adaptiveCard has-image"><div class="ac-textBlock"><p>Here’s a Suricata IPS rule that meets your requirements:</p><pre><code class="language-yaml"><span class="hljs-string">alert</span> <span class="hljs-string">http</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">(msg:"Blocked</span> <span class="hljs-string">potential</span> <span class="hljs-string">SSH</span> <span class="hljs-string">credential</span> <span class="hljs-string">theft</span> <span class="hljs-string">attack</span> <span class="hljs-string">from</span> <span class="hljs-string">&lt;source</span> <span class="hljs-string">IP&gt;</span> <span class="hljs-string">on</span> <span class="hljs-string">&lt;destination</span> <span class="hljs-string">IP&gt;</span> <span class="hljs-string">at</span> <span class="hljs-string">&lt;time&gt;";</span> <span class="hljs-string">content:"userfile=@/etc/passwd";</span> <span class="hljs-string">nocase;</span> <span class="hljs-string">http_uri;</span> <span class="hljs-string">sid:1000005;</span> <span class="hljs-string">rev:1;)</span>
<span class="hljs-string">alert</span> <span class="hljs-string">http</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">(msg:"Blocked</span> <span class="hljs-string">potential</span> <span class="hljs-string">SSH</span> <span class="hljs-string">credential</span> <span class="hljs-string">theft</span> <span class="hljs-string">attack</span> <span class="hljs-string">from</span> <span class="hljs-string">&lt;source</span> <span class="hljs-string">IP&gt;</span> <span class="hljs-string">on</span> <span class="hljs-string">&lt;destination</span> <span class="hljs-string">IP&gt;</span> <span class="hljs-string">at</span> <span class="hljs-string">&lt;time&gt;";</span> <span class="hljs-string">content:"userfile=@/etc/hosts";</span> <span class="hljs-string">nocase;</span> <span class="hljs-string">http_uri;</span> <span class="hljs-string">sid:1000006;</span> <span class="hljs-string">rev:1;)</span>
<span class="hljs-string">drop</span> <span class="hljs-string">http</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">(msg:"Blocking</span> <span class="hljs-string">potential</span> <span class="hljs-string">SSH</span> <span class="hljs-string">credential</span> <span class="hljs-string">theft</span> <span class="hljs-string">attack";</span> <span class="hljs-string">content:"userfile=@/etc/passwd";</span> <span class="hljs-string">nocase;</span> <span class="hljs-string">http_uri;</span> <span class="hljs-string">sid:1000007;</span> <span class="hljs-string">rev:1;)</span>
<span class="hljs-string">drop</span> <span class="hljs-string">http</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">any</span> <span class="hljs-string">any</span> <span class="hljs-string">(msg:"Blocking</span> <span class="hljs-string">potential</span> <span class="hljs-string">SSH</span> <span class="hljs-string">credential</span> <span class="hljs-string">theft</span> <span class="hljs-string">attack";</span> <span class="hljs-string">content:"userfile=@/etc/hosts";</span> <span class="hljs-string">nocase;</span> <span class="hljs-string">http_uri;</span> <span class="hljs-string">sid:1000008;</span> <span class="hljs-string">rev:1;)</span>
</code></pre><p>This rule does the following:</p><ol><li><strong>Detects incoming connections</strong> containing “userfile=@/etc/passwd” or “userfile=@/etc/hosts”.</li><li><strong>Blocks the connection</strong> if such patterns are detected.</li><li><strong>Generates a log</strong> with the message “Blocked potential SSH credential theft attack from &lt;source IP&gt; on &lt;destination IP&gt; at &lt;time&gt;”.</li></ol><p>Feel free to adjust the <code>sid</code> (Signature ID) and <code>rev</code> (Revision) numbers as needed. Let me know if you need any further customization!</p></div></div></div></blockquote><h2>Comparing and Contrasting:</h2><p>There's some interesting tidbits that came out of this:</p><ul><li>ChatGPT took the longest time between entering the first prompt and generating a response.</li><li>ChatGPT's responses provide more information about how Suricata rules operate and how to craft them on your own, making it a better resource for beginner/occassional/intermediate users.</li><li>None of the ChatGPT responses provided the full set of protocols supported by Suricata, which means referencing the documentation or creating a prompt specifically about that is required to obtain that information.</li><li>Bing Copilot's responses are much more to the point, making them better for experienced users/people under time pressure.</li><li>I suspect that using two different prompts in the same session causes some form of response contamination due to improper context cleanup. Both AI seem to default to HTTP being the protocol of choice, which makes sense for the first prompt, but is flat out wrong for the second prompt.*</li><li>There is a lingering question about the available data on Suricata for training/Retrieval Augmented Generation. If most publicly accessible data is for HTTP Suricata rules, that might bias the results towards generating HTTP rules.</li></ul><p>*To be fair, I did not provide either AI with any information regarding the protocol to use for the second prompt. That was intentional, as part of the testing process.</p><h2>The Unexpected Roadblock</h2><figure class="post__image"><img loading="lazy" src="https://korgano.github.io/media/posts/23/cyber-proj-tfb06.png" alt="ThriveDX login error screen." width="1920" height="912" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-xs.png 384w, https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-sm.png 600w, https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-md.png 768w, https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-lg.png 1200w, https://korgano.github.io/media/posts/23/responsive/cyber-proj-tfb06-xl.png 1600w"></figure><p>To my lack of surprise, ThriveDX let me down when I needed it, right when a hurricane passed by my part of Florida.</p><p>However, OPNsense released a new version with a wide range of updates, so perhaps I can make some progress by redoing the install from scratch...</p></div><footer class="content__footer"><div class="content__tag-share"><div class="content__tag"><h3 class="content__tag__title">Posted in</h3><ul class="content__tag__list"><li><a href="https://korgano.github.io/tags/ai/">AI</a></li><li><a href="https://korgano.github.io/tags/cybersecurity/">Cybersecurity</a></li><li><a href="https://korgano.github.io/tags/cybersecurity-projects/">Cybersecurity Projects</a></li><li><a href="https://korgano.github.io/tags/tech/">Tech</a></li></ul></div><div class="content__share"><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fkorgano.github.io%2Fcybersecurity-project-transparent-filtering-bridge-extras-40%2F" class="js-share linkedin" aria-label="Share with LinkedIn" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://korgano.github.io/assets/svg/svg-map.svg#linkedin"/></svg></a></div></div></footer></div></article><div class="content__related"><h3 class="content__related__title">Related posts</h3><div class="l-grid l-grid--2"><article class="c-card"><div class="c-card__wrapper"><figure class="c-card__image is-img-loading"><img src="https://korgano.github.io/media/posts/10/glenn-carstens-peters-npxXWgQ33ZQ-unsplash.jpg" srcset="https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-xs.jpg 384w, https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-sm.jpg 600w, https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-md.jpg 768w, https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-lg.jpg 1200w" sizes="(min-width: 37.5em) 80vw, 50vw" loading="lazy" height="2712" width="4076" alt=""></figure><div class="c-card__content"><header><h2 class="c-card__title"><a href="https://korgano.github.io/cybersecurity-project-research-remote-access/" class="invert">Cybersecurity Project Research: Remote Access</a></h2></header><footer class="c-card__meta"><a href="https://korgano.github.io/tags/cybersecurity-projects/" class="c-card__tag">Cybersecurity Projects</a></footer></div></div></article><article class="c-card"><div class="c-card__wrapper"><figure class="c-card__image is-img-loading"><img src="https://korgano.github.io/media/posts/9/andres-urena-vXPXRp_wIg4-unsplash.jpg" srcset="https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-xs.jpg 384w, https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-sm.jpg 600w, https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-md.jpg 768w, https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-lg.jpg 1200w" sizes="(min-width: 37.5em) 80vw, 50vw" loading="lazy" height="1687" width="3000" alt=""></figure><div class="c-card__content"><header><h2 class="c-card__title"><a href="https://korgano.github.io/cybersecurity-headache-home-router-uxui/" class="invert">Cybersecurity Headache: Home Router UXUI</a></h2></header><footer class="c-card__meta"><a href="https://korgano.github.io/tags/quick-thoughts/" class="c-card__tag">Quick Thoughts</a></footer></div></div></article></div></div></main><footer class="footer"><div class="footer__left"><div class="footer__copy">Copyright Xavier Santana, 2023-2025. Powered by Publii.</div></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://korgano.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = { mobileMenuMode: 'sidebar', animationSpeed: 300, submenuWidth: 'auto', doubleClickTime: 500, mobileMenuExpandableSubmenus: true, relatedContainerForOverlayMenuSelector: '.navbar', };</script><script defer="defer" src="https://korgano.github.io/assets/js/scripts.min.js?v=9c5ab7a87221183f149a42b3cceb7956"></script><script>function publiiDetectLoadedImages () {
         var images = document.querySelectorAll('img[loading]:not(.is-loaded)');
         for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
               images[i].classList.add('is-loaded');
               images[i].parentNode.classList.remove('is-img-loading');
            } else {
               images[i].addEventListener('load', function () {
                  this.classList.add('is-loaded');
                  this.parentNode.classList.remove('is-img-loading');
               }, false);
            }
         }
      }
      publiiDetectLoadedImages();</script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-line-numbers.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/clipboard.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-copy-to-clipboard.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-inline-color.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-show-invisibles.min.js"></script><!-- Start main cookie container --><div class="pcb" data-behaviour="badge" data-behaviour-link="#cookie-settings" data-revision="1" data-config-ttl="90" data-debug-mode="false"><!-- Start Banner --><div role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="pcb-title" aria-describedby="pcb-txt" class="pcb__banner"><div class="pcb__inner"><div id="pcb-title" role="heading" aria-level="2" class="pcb__title">This website uses cookies</div><div id="pcb-txt" class="pcb__txt">Select which cookies to opt-in to via the checkboxes below; our website uses cookies to examine site traffic and user activity while on our site, for marketing, and to provide social media functionality. <a href="https://korgano.github.io/privacy-policy/">More details...</a></div><div class="pcb__buttons"><button type="button" class="pcb__btn pcb__btn--solid pcb__btn--accept">Accept all</button></div></div></div><!-- End of Banner --><!-- Badge --> <button class="pcb__badge" aria-label="Cookie Policy" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" width="40" height="40" viewBox="0 0 23 23" fill="currentColor"><path d="M21.41 12.71c-.08-.01-.15 0-.22 0h-.03c-.03 0-.05 0-.08.01-.07 0-.13.01-.19.04-.52.21-1.44.19-2.02-.22-.44-.31-.65-.83-.62-1.53a.758.758 0 0 0-.27-.61.73.73 0 0 0-.65-.14c-1.98.51-3.49.23-4.26-.78-.82-1.08-.73-2.89.24-4.49.14-.23.14-.52 0-.75a.756.756 0 0 0-.67-.36c-.64.03-1.11-.1-1.31-.35-.19-.26-.13-.71-.01-1.29.04-.18.06-.38.03-.59-.05-.4-.4-.7-.81-.66C5.1 1.54 1 6.04 1 11.48 1 17.28 5.75 22 11.6 22c5.02 0 9.39-3.54 10.39-8.42.08-.4-.18-.78-.58-.87Zm-9.81 7.82c-5.03 0-9.12-4.06-9.12-9.06 0-4.34 3.05-8 7.25-8.86-.08.7.05 1.33.42 1.81.24.32.66.67 1.38.84-.76 1.86-.65 3.78.36 5.11.61.81 2.03 2 4.95 1.51.18.96.71 1.54 1.18 1.87.62.43 1.38.62 2.1.62.05 0 .09 0 .13-.01-1.23 3.64-4.7 6.18-8.64 6.18ZM13 17c0 .55-.45 1-1 1s-1-.45-1-1 .45-1 1-1 1 .45 1 1Zm5.29-12.3a.99.99 0 0 1-.29-.71c0-.55.45-.99 1-.99a1 1 0 0 1 .71.3c.19.19.29.44.29.71 0 .55-.45.99-1 .99a1 1 0 0 1-.71-.3ZM9 13.5c0 .83-.67 1.5-1.5 1.5S6 14.33 6 13.5 6.67 12 7.5 12s1.5.67 1.5 1.5Zm3.25.81a.744.744 0 0 1-.06-1.05c.28-.32.75-.34 1.05-.06.31.28.33.75.05 1.06-.15.16-.35.25-.56.25-.18 0-.36-.06-.5-.19ZM8.68 7.26c.41.37.44 1 .07 1.41-.2.22-.47.33-.75.33a.96.96 0 0 1-.67-.26c-.41-.37-.44-1-.07-1.41.37-.42 1-.45 1.41-.08Zm11.48 1.88c.18-.19.52-.19.7 0 .05.04.09.1.11.16.03.06.04.12.04.19 0 .13-.05.26-.15.35-.09.1-.22.15-.35.15s-.26-.05-.35-.15a.355.355 0 0 1-.11-.16.433.433 0 0 1-.04-.19c0-.13.05-.26.15-.35Zm-4.93-1.86a.75.75 0 1 1 1.059-1.06.75.75 0 0 1-1.059 1.06Z"/></svg></button><!-- End of Badge --></div><!-- End of main cookie container --><script>(function(win) {
    if (!document.querySelector('.pcb')) {
        return;
    }

    var cbConfig = {
        behaviour: document.querySelector('.pcb').getAttribute('data-behaviour'),
        behaviourLink: document.querySelector('.pcb').getAttribute('data-behaviour-link'),
        revision: document.querySelector('.pcb').getAttribute('data-revision'),
        configTTL: parseInt(document.querySelector('.pcb').getAttribute('data-config-ttl'), 10),
        debugMode: document.querySelector('.pcb').getAttribute('data-debug-mode') === 'true',
        initialState: null,
        initialLsState: null,
        previouslyAccepted: []
    };

    var cbUI = {
        wrapper: document.querySelector('.pcb'),
        banner: {
            element: null,
            btnAccept: null,
            btnReject: null,
            btnConfigure: null
        },
        popup: {
            element: null,
            btnClose: null,
            btnSave: null,
            btnAccept: null,
            btnReject: null,
            checkboxes: null,
        },
        overlay: null,
        badge: null,
        blockedScripts: document.querySelectorAll('script[type^="gdpr-blocker/"]'),
        triggerLinks: cbConfig.behaviourLink ? document.querySelectorAll('a[href*="' + cbConfig.behaviourLink + '"]') : null
    };

    function initUI () {
        // setup banner elements
        cbUI.banner.element = cbUI.wrapper.querySelector('.pcb__banner');
        cbUI.banner.btnAccept = cbUI.banner.element.querySelector('.pcb__btn--accept');
        cbUI.banner.btnReject = cbUI.banner.element.querySelector('.pcb__btn--reject');
        cbUI.banner.btnConfigure = cbUI.banner.element.querySelector('.pcb__btn--configure');

        // setup popup elements
        if (cbUI.wrapper.querySelector('.pcb__popup')) {
            cbUI.popup.element = cbUI.wrapper.querySelector('.pcb__popup');
            cbUI.popup.btnClose = cbUI.wrapper.querySelector('.pcb__popup__close');
            cbUI.popup.btnSave = cbUI.popup.element.querySelector('.pcb__btn--save');
            cbUI.popup.btnAccept = cbUI.popup.element.querySelector('.pcb__btn--accept');
            cbUI.popup.btnReject = cbUI.popup.element.querySelector('.pcb__btn--reject');
            cbUI.popup.checkboxes = cbUI.popup.element.querySelector('input[type="checkbox"]');
            // setup overlay
            cbUI.overlay = cbUI.wrapper.querySelector('.pcb__overlay');
        }

        cbUI.badge = cbUI.wrapper.querySelector('.pcb__badge');

        if (cbConfig.behaviour.indexOf('link') > -1) {
            for (var i = 0; i < cbUI.triggerLinks.length; i++) {
                cbUI.triggerLinks[i].addEventListener('click', function(e) {
                    e.preventDefault();
                    showBannerOrPopup();
                });
            }
        }
    }

    function initState () {
        var lsKeyName = getConfigName();
        var currentConfig = localStorage.getItem(lsKeyName);
        var configIsFresh = checkIfConfigIsFresh();

        if (!configIsFresh || currentConfig === null) {
            if (cbConfig.debugMode) {
                console.log('🍪 Config not found, or configuration expired');
            }

            if (window.publiiCBGCM) {
                gtag('consent', 'default', {
                    'ad_storage': window.publiiCBGCM.defaultState.ad_storage ? 'granted' : 'denied',
                    'ad_personalization': window.publiiCBGCM.defaultState.ad_personalization ? 'granted' : 'denied',
                    'ad_user_data': window.publiiCBGCM.defaultState.ad_user_data ? 'granted' : 'denied',
                    'analytics_storage': window.publiiCBGCM.defaultState.analytics_storage ? 'granted' : 'denied',
                    'personalization_storage': window.publiiCBGCM.defaultState.personalization_storage ? 'granted' : 'denied',
                    'functionality_storage': window.publiiCBGCM.defaultState.functionality_storage ? 'granted' : 'denied',
                    'security_storage': window.publiiCBGCM.defaultState.security_storage ? 'granted' : 'denied'
                });  
                
                if (cbConfig.debugMode) {
                    console.log('🍪 GCMv2 DEFAULT STATE: ' + JSON.stringify({
                        'ad_storage': window.publiiCBGCM.defaultState.ad_storage ? 'granted' : 'denied',
                        'ad_personalization': window.publiiCBGCM.defaultState.ad_personalization ? 'granted' : 'denied',
                        'ad_user_data': window.publiiCBGCM.defaultState.ad_user_data ? 'granted' : 'denied',
                        'analytics_storage': window.publiiCBGCM.defaultState.analytics_storage ? 'granted' : 'denied',
                        'personalization_storage': window.publiiCBGCM.defaultState.personalization_storage ? 'granted' : 'denied',
                        'functionality_storage': window.publiiCBGCM.defaultState.functionality_storage ? 'granted' : 'denied',
                        'security_storage': window.publiiCBGCM.defaultState.security_storage ? 'granted' : 'denied'
                    }));
                }
            }

            showBanner();
        } else if (typeof currentConfig === 'string') {
            if (cbConfig.debugMode) {
                console.log('🍪 Config founded');
            }

            cbConfig.initialLsState = currentConfig.split(',');

            if (window.publiiCBGCM) {
                gtag('consent', 'default', {
                    'ad_storage': getDefaultConsentState(currentConfig, 'ad_storage'),
                    'ad_personalization': getDefaultConsentState(currentConfig, 'ad_personalization'),
                    'ad_user_data': getDefaultConsentState(currentConfig, 'ad_user_data'),
                    'analytics_storage': getDefaultConsentState(currentConfig, 'analytics_storage'),
                    'personalization_storage': getDefaultConsentState(currentConfig, 'personalization_storage'),
                    'functionality_storage': getDefaultConsentState(currentConfig, 'functionality_storage'),
                    'security_storage': getDefaultConsentState(currentConfig, 'security_storage')
                });
                
                if (cbConfig.debugMode) {
                    console.log('🍪 GCMv2 DEFAULT STATE: ' + JSON.stringify({
                        'ad_storage': getDefaultConsentState(currentConfig, 'ad_storage'),
                        'ad_personalization': getDefaultConsentState(currentConfig, 'ad_personalization'),
                        'ad_user_data': getDefaultConsentState(currentConfig, 'ad_user_data'),
                        'analytics_storage': getDefaultConsentState(currentConfig, 'analytics_storage'),
                        'personalization_storage': getDefaultConsentState(currentConfig, 'personalization_storage'),
                        'functionality_storage': getDefaultConsentState(currentConfig, 'functionality_storage'),
                        'security_storage': getDefaultConsentState(currentConfig, 'security_storage')
                    }));
                }
            }

            showBadge();

            if (cbUI.popup.element) {
                var allowedGroups = currentConfig.split(',');
                var checkedCheckboxes = cbUI.popup.element.querySelectorAll('input[type="checkbox"]:checked');

                for (var j = 0; j < checkedCheckboxes.length; j++) {
                    var name = checkedCheckboxes[j].getAttribute('data-group-name');

                    if (name && name !== '-' && allowedGroups.indexOf(name) === -1) {
                        checkedCheckboxes[j].checked = false;
                    }
                }

                for (var i = 0; i < allowedGroups.length; i++) {
                    var checkbox = cbUI.popup.element.querySelector('input[type="checkbox"][data-group-name="' + allowedGroups[i] + '"]');

                    if (checkbox) {
                        checkbox.checked = true;
                    }

                    allowCookieGroup(allowedGroups[i]);
                }
            }
        }

        setTimeout(function () {
            cbConfig.initialState = getInitialStateOfConsents();
        }, 0);
    }

    function checkIfConfigIsFresh () {
        var lastConfigSave = localStorage.getItem('publii-gdpr-cookies-config-save-date');

        if (lastConfigSave === null) {
            return false;
        }

        lastConfigSave = parseInt(lastConfigSave, 10);

        if (lastConfigSave === 0) {
            return true;
        }

        if (+new Date() - lastConfigSave < cbConfig.configTTL * 24 * 60 * 60 * 1000) {
            return true;
        }

        return false;
    }

    function getDefaultConsentState (currentConfig, consentGroup) {
        let configGroups = currentConfig.split(',');

        for (let i = 0; i < configGroups.length; i++) {
            let groupName = configGroups[i];
            let group = window.publiiCBGCM.groups.find(group => group.cookieGroup === groupName);

            if (group && group[consentGroup]) {
                return 'granted';
            }
        }  
        
        if (window.publiiCBGCM.defaultState[consentGroup]) {
            return 'granted'; 
        }
        
        return 'denied';
    }

    function initBannerEvents () {
        cbUI.banner.btnAccept.addEventListener('click', function (e) {
            e.preventDefault();
            acceptAllCookies('banner');
            showBadge();
        }, false);

        if (cbUI.banner.btnReject) {
            cbUI.banner.btnReject.addEventListener('click', function (e) {
                e.preventDefault();
                rejectAllCookies();
                showBadge();
            }, false);
        }

        if (cbUI.banner.btnConfigure) {
            cbUI.banner.btnConfigure.addEventListener('click', function (e) {
                e.preventDefault();
                hideBanner();
                showAdvancedPopup();
                showBadge();
            }, false);
        }
    }

    function initPopupEvents () {
        if (!cbUI.popup.element) {
            return;
        }

        cbUI.overlay.addEventListener('click', function (e) {
            hideAdvancedPopup();
        }, false);

        cbUI.popup.element.addEventListener('click', function (e) {
            e.stopPropagation();
        }, false);

        cbUI.popup.btnAccept.addEventListener('click', function (e) {
            e.preventDefault();
            acceptAllCookies('popup');
        }, false);

        cbUI.popup.btnReject.addEventListener('click', function (e) {
            e.preventDefault();
            rejectAllCookies();
        }, false);

        cbUI.popup.btnSave.addEventListener('click', function (e) {
            e.preventDefault();
            saveConfiguration();
        }, false);

        cbUI.popup.btnClose.addEventListener('click', function (e) {
            e.preventDefault();
            hideAdvancedPopup();
        }, false);
    }

    function initBadgeEvents () {
        if (!cbUI.badge) {
            return;
        }

        cbUI.badge.addEventListener('click', function (e) {
            showBannerOrPopup();
        }, false);
    }

    initUI();
    initState();
    initBannerEvents();
    initPopupEvents();
    initBadgeEvents();

    /**
     * API
     */
    function addScript (src, inline) {
        var newScript = document.createElement('script');

        if (src) {
            newScript.setAttribute('src', src);
        }

        if (inline) {
            newScript.text = inline;
        }

        document.body.appendChild(newScript);
    }

    function allowCookieGroup (allowedGroup) {
        var scripts = document.querySelectorAll('script[type="gdpr-blocker/' + allowedGroup + '"]');
        cbConfig.previouslyAccepted.push(allowedGroup);
    
        for (var j = 0; j < scripts.length; j++) {
            addScript(scripts[j].src, scripts[j].text);
        }

        var groupEvent = new Event('publii-cookie-banner-unblock-' + allowedGroup);
        document.body.dispatchEvent(groupEvent);
        unlockEmbeds(allowedGroup);

        if (cbConfig.debugMode) {
            console.log('🍪 Allowed group: ' + allowedGroup);
        }

        if (window.publiiCBGCM && (!cbConfig.initialLsState || cbConfig.initialLsState.indexOf(allowedGroup) === -1)) {
            let consentResult = {};
            let group = window.publiiCBGCM.groups.find(group => group.cookieGroup === allowedGroup);

            if (group) {
                let foundSomeConsents = false;

                Object.keys(group).forEach(key => {
                    if (key !== 'cookieGroup' && group[key] === true) {
                        consentResult[key] = 'granted';
                        foundSomeConsents = true;
                    }
                });

                if (foundSomeConsents) {
                    gtag('consent', 'update', consentResult);   

                    if (cbConfig.debugMode) {
                        console.log('🍪 GCMv2 UPDATE: ' + JSON.stringify(consentResult));
                    }
                }
            }
        }
    }

    function showBannerOrPopup () {
        if (cbUI.popup.element) {
            showAdvancedPopup();
        } else {
            showBanner();
        }
    }

    function showAdvancedPopup () {
        cbUI.popup.element.classList.add('is-visible');
        cbUI.overlay.classList.add('is-visible');
        cbUI.popup.element.setAttribute('aria-hidden', 'false');
        cbUI.overlay.setAttribute('aria-hidden', 'false');
    }

    function hideAdvancedPopup () {
        cbUI.popup.element.classList.remove('is-visible');
        cbUI.overlay.classList.remove('is-visible');
        cbUI.popup.element.setAttribute('aria-hidden', 'true');
        cbUI.overlay.setAttribute('aria-hidden', 'true');
    }

    function showBanner () {
        cbUI.banner.element.classList.add('is-visible');
        cbUI.banner.element.setAttribute('aria-hidden', 'false');
    }

    function hideBanner () {
        cbUI.banner.element.classList.remove('is-visible');
        cbUI.banner.element.setAttribute('aria-hidden', 'true');
    }

    function showBadge () {
        if (!cbUI.badge) {
            return;
        }

        cbUI.badge.classList.add('is-visible');
        cbUI.badge.setAttribute('aria-hidden', 'false');
    }

    function getConfigName () {
        var lsKeyName = 'publii-gdpr-allowed-cookies';

        if (cbConfig.revision) {
            lsKeyName = lsKeyName + '-v' + parseInt(cbConfig.revision, 10);
        }

        return lsKeyName;
    }

    function storeConfiguration (allowedGroups) {
        var lsKeyName = getConfigName();
        var dataToStore = allowedGroups.join(',');
        localStorage.setItem(lsKeyName, dataToStore);

        if (cbConfig.configTTL === 0) {
            localStorage.setItem('publii-gdpr-cookies-config-save-date', 0);

            if (cbConfig.debugMode) {
                console.log('🍪 Store never expiring configuration');
            }
        } else {
            localStorage.setItem('publii-gdpr-cookies-config-save-date', +new Date());
        }
    }

    function getInitialStateOfConsents () {
        if (!cbUI.popup.element) {
            return [];
        }

        var checkedGroups = cbUI.popup.element.querySelectorAll('input[type="checkbox"]:checked');
        var groups = [];

        for (var i = 0; i < checkedGroups.length; i++) {
            var allowedGroup = checkedGroups[i].getAttribute('data-group-name');

            if (allowedGroup !== '') {
                groups.push(allowedGroup);
            }
        }

        if (cbConfig.debugMode) {
            console.log('🍪 Initial state: ' + groups.join(', '));
        }

        return groups;
    }

    function getCurrentStateOfConsents () {
        if (!cbUI.popup.element) {
            return [];
        }

        var checkedGroups = cbUI.popup.element.querySelectorAll('input[type="checkbox"]:checked');
        var groups = [];

        for (var i = 0; i < checkedGroups.length; i++) {
            var allowedGroup = checkedGroups[i].getAttribute('data-group-name');

            if (allowedGroup !== '') {
                groups.push(allowedGroup);
            }
        }

        if (cbConfig.debugMode) {
            console.log('🍪 State to save: ' + groups.join(', '));
        }

        return groups;
    }

    function getAllGroups () {
        if (!cbUI.popup.element) {
            return [];
        }

        var checkedGroups = cbUI.popup.element.querySelectorAll('input[type="checkbox"]');
        var groups = [];

        for (var i = 0; i < checkedGroups.length; i++) {
            var allowedGroup = checkedGroups[i].getAttribute('data-group-name');

            if (allowedGroup !== '') {
                groups.push(allowedGroup);
            }
        }

        return groups;
    }

    function acceptAllCookies (source) {
        var groupsToAccept = getAllGroups();
        storeConfiguration(groupsToAccept);

        for (var i = 0; i < groupsToAccept.length; i++) {
            var group = groupsToAccept[i];

            if (cbConfig.initialState.indexOf(group) > -1 || cbConfig.previouslyAccepted.indexOf(group) > -1) {
                if (cbConfig.debugMode) {
                    console.log('🍪 Skip previously activated group: ' + group);
                }

                continue;
            }

            allowCookieGroup(group);
        }

        if (cbUI.popup.element) {
            var checkboxesToCheck = cbUI.popup.element.querySelectorAll('input[type="checkbox"]');

            for (var j = 0; j < checkboxesToCheck.length; j++) {
                checkboxesToCheck[j].checked = true;
            }
        }

        if (cbConfig.debugMode) {
            console.log('🍪 Accept all cookies: ', groupsToAccept.join(', '));
        }

        if (source === 'popup') {
            hideAdvancedPopup();
        } else if (source === 'banner') {
            hideBanner();
        }
    }

    function rejectAllCookies () {
        if (cbConfig.debugMode) {
            console.log('🍪 Reject all cookies');
        }

        storeConfiguration([]);
        setTimeout(function () {
            window.location.reload();
        }, 100);
    }

    function saveConfiguration () {
        var groupsToAccept = getCurrentStateOfConsents();
        storeConfiguration(groupsToAccept);

        if (cbConfig.debugMode) {
            console.log('🍪 Save new config: ', groupsToAccept.join(', '));
        }

        if (reloadIsNeeded(groupsToAccept)) {
            setTimeout(function () {
                window.location.reload();
            }, 100);
            return;
        }

        for (var i = 0; i < groupsToAccept.length; i++) {
            var group = groupsToAccept[i];

            if (cbConfig.initialState.indexOf(group) > -1 || cbConfig.previouslyAccepted.indexOf(group) > -1) {
                if (cbConfig.debugMode) {
                    console.log('🍪 Skip previously activated group: ' + group);
                }

                continue;
            }

            allowCookieGroup(group);
        }

        hideAdvancedPopup();
    }

    function reloadIsNeeded (groupsToAccept) {
        // check if user rejected consent for initial groups
        var initialGroups = cbConfig.initialState;
        var previouslyAcceptedGroups = cbConfig.previouslyAccepted;
        var groupsToCheck = initialGroups.concat(previouslyAcceptedGroups);

        for (var i = 0; i < groupsToCheck.length; i++) {
            var groupToCheck = groupsToCheck[i];

            if (groupToCheck !== '' && groupsToAccept.indexOf(groupToCheck) === -1) {
                if (cbConfig.debugMode) {
                    console.log('🍪 Reload is needed due lack of: ', groupToCheck);
                }

                return true;
            }
        }

        return false;
    }

    function unlockEmbeds (cookieGroup) {
        var iframesToUnlock = document.querySelectorAll('.pec-wrapper[data-consent-group-id="' + cookieGroup + '"]');

        for (var i = 0; i < iframesToUnlock.length; i++) {
            var iframeWrapper = iframesToUnlock[i];
            iframeWrapper.querySelector('.pec-overlay').classList.remove('is-active');
            iframeWrapper.querySelector('.pec-overlay').setAttribute('aria-hidden', 'true');
            var iframe = iframeWrapper.querySelector('iframe');
            iframe.setAttribute('src', iframe.getAttribute('data-consent-src'));
        }
    }

    win.publiiEmbedConsentGiven = function (cookieGroup) {
        // it will unlock embeds
        allowCookieGroup(cookieGroup);

        var checkbox = cbUI.popup.element.querySelector('input[type="checkbox"][data-group-name="' + cookieGroup + '"]');

        if (checkbox) {
            checkbox.checked = true;
        }

        var groupsToAccept = getCurrentStateOfConsents();
        storeConfiguration(groupsToAccept);

        if (cbConfig.debugMode) {
            console.log('🍪 Save new config: ', groupsToAccept.join(', '));
        }
    }
})(window);</script></body></html>