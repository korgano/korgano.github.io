<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 3.0 - XS Tech Thoughts</title><meta name="description" content="%pagetitles: Cybersecurity professional experiments with Bing Copilot and ChatGPT for OPNsense firewall rule generation."><meta name="generator" content="Publii Open-Source CMS for Static Site"><!-- Global site tag (gtag.js) - Google Analytics --><script type="gdpr-blocker/Analytics" async src="https://www.googletagmanager.com/gtag/js?id=G-EHLH28GQMY"></script><script type="gdpr-blocker/Analytics">window.dataLayer = window.dataLayer || [];
				  function gtag(){dataLayer.push(arguments);}
				  gtag('js', new Date());
				  gtag('config', 'G-EHLH28GQMY' , { 'anonymize_ip': true });
				  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EHLH28GQMY"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EHLH28GQMY');</script><link rel="stylesheet" href="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-black.css"><link rel="stylesheet" href="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-inline-color.css"><link rel="canonical" href="https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-30/"><link rel="alternate" type="application/atom+xml" href="https://korgano.github.io/feed.xml"><meta property="og:title" content="CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 3.0"><meta property="og:image" content="https://korgano.github.io/media/posts/22/jj-ying-8bghKxNU1j0-unsplash.jpg"><meta property="og:image:width" content="4032"><meta property="og:image:height" content="3024"><meta property="og:site_name" content="XS Tech Thoughts"><meta property="og:description" content="%pagetitles: Cybersecurity professional experiments with Bing Copilot and ChatGPT for OPNsense firewall rule generation."><meta property="og:url" content="https://korgano.github.io//cybersecurity-project-transparent-filtering-bridge-extras-30/"><meta property="og:type" content="article"><link rel="preload" href="https://korgano.github.io/assets/dynamic/fonts/robotoflex/robotoflex.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://korgano.github.io/assets/dynamic/fonts/robotoslab/robotoslab.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://korgano.github.io/assets/css/style.css?v=338ed96ce9bc0f6c72a02763a377a303"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-30/"},"headline":"CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 3.0","datePublished":"2024-09-11T10:13","dateModified":"2024-09-12T13:48","image":{"@type":"ImageObject","url":"https://korgano.github.io/media/posts/22/jj-ying-8bghKxNU1j0-unsplash.jpg","height":3024,"width":4032},"description":"%pagetitles: Cybersecurity professional experiments with Bing Copilot and ChatGPT for OPNsense firewall rule generation.","author":{"@type":"Person","name":"Xavier Santana","url":"https://korgano.github.io/authors/xavier-santana/"},"publisher":{"@type":"Organization","name":"Xavier Santana"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template lines"><div class="container lines lines--right"><header class="header"><a href="https://korgano.github.io/" class="logo">XS Tech Thoughts</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu">Menu</button><ul class="navbar__menu"><li><a href="https://korgano.github.io/" title="Home" target="_self">Home</a></li><li><a href="https://korgano.github.io/tags/uxui-case-study/" title="UX/UI Case Studies" target="_blank">UX/UI Case Studies</a></li><li><a href="https://korgano.github.io/tags/cybersecurity-projects/" title="Cybersecurity Projects" target="_blank">Cybersecurity Projects</a></li><li><a href="https://korgano.github.io/tags/quick-thoughts/" title="Quick Thoughts" target="_self">Quick Thoughts</a></li><li><a href="https://korgano.github.io/about-me/" title="About Me" target="_blank">About Me</a></li></ul></nav></header><main class="main post"><article class="content"><header class="content__inner content__header"><h1 class="content__title">CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 3.0</h1><div class="content__meta"><div class="content__meta__left"><a href="https://korgano.github.io/authors/xavier-santana/" class="invert content__author" rel="author" title="Xavier Santana">Xavier Santana</a></div><div class="content__meta__right"><time datetime="2024-09-11T10:13" class="content__date">September 11, 2024</time><div class="content__updated">Updated on <time datetime="2024-09-11T10:13" class="content__date">September 12, 2024</time></div></div></div></header><figure class="content__featured-image"><div class="content__featured-image__inner is-img-loading"><img src="https://korgano.github.io/media/posts/22/jj-ying-8bghKxNU1j0-unsplash.jpg" srcset="https://korgano.github.io/media/posts/22/responsive/jj-ying-8bghKxNU1j0-unsplash-xs.jpg 384w, https://korgano.github.io/media/posts/22/responsive/jj-ying-8bghKxNU1j0-unsplash-sm.jpg 600w, https://korgano.github.io/media/posts/22/responsive/jj-ying-8bghKxNU1j0-unsplash-md.jpg 768w, https://korgano.github.io/media/posts/22/responsive/jj-ying-8bghKxNU1j0-unsplash-lg.jpg 1200w, https://korgano.github.io/media/posts/22/responsive/jj-ying-8bghKxNU1j0-unsplash-xl.jpg 1600w" sizes="(min-width: 37.5em) 1600px, 80vw" loading="eager" height="3024" width="4032" alt="Fiber optic bundle by JJ Ying on Unsplash"></div><figcaption>By JJ Ying on Unsplash</figcaption></figure><div class="content__inner"><div class="content__entry"><p><a href="https://korgano.github.io/cybersecurity-project-transparent-filtering-bridge-extras-20/" title="CyberSecurity Project: Transparent Filtering Bridge (+ Extras) 2.0: CLI is a UX Failure" target="_blank" rel="noopener noreferrer">Last time</a>, I ran into a number of issues in terms of the actual implementation of the transparent filtering bridge, with the most severe being the inability to actually manage it when connected to my network.</p><p>Instead of scuttling the whole time, I decided to sidestep the issue for the moment, and move on to the next part of the process, making firewall rules.</p><p>But for this step, I want do something a little more interesting.</p><p>So, instead of just documenting how I make a rule for OPNsense, I'm going to make this a three-way competition: me vs ChatGPT vs Bing Copilot!</p><h2>Step 1: Which Guide to Use?</h2><p>When it comes to doing any kind of configuration by hand, success or failure can often depend on what guidance you have.</p><p>There are two obvious guiding documents for this task:</p><ul><li><a href="https://docs.opnsense.org/manual/firewall.html" target="_blank" rel="noopener noreferrer">OPNsense's Firewall Rule documentation</a></li><li><a href="https://www.zenarmor.com/docs/network-security-tutorials/how-to-configure-opnsense-firewall-rules" title="How to Configure OPNsense Firewall Rules?" target="_blank" rel="noopener noreferrer">ZenArmor's guide on configuring OPNsense firewall rules</a></li></ul><p>Of the two, the ZenArmor guide is¬†<strong>vastly¬†</strong>more useful. Not only does it explain how things work, it breaks down the process of setting up a rule, provides several examples of common rules,¬†<strong>and¬†</strong>has a large number of images so you can check yourself throughout the process.</p><h2>Step 2: What to Block?</h2><p>Making firewall rules is a lot like threat hunting: you have to make an assumption that a threat is present, so you can actually have a direction for action.</p><p>In this case, I don't have to make the assumption. I¬†<strong>know¬†</strong>I have Amazon devices with Alexa voice control in my home.</p><p>So, in this case, I want to block outbound traffic to Amazon's Alexa servers.</p><h2>Step 3: What IP Address Does Alexa's Server Use?</h2><p>Obviously, to stop traffic going to the server, I have to know the IP address that's receiving the data.</p><p>Thankfully, the question <code>what are the ip addresses for amazon alexa servers</code> provided me with an easily verifiable answer via <a href="https://www.netify.ai/resources/ips/44.199.80.228" title="44.199.80.228 - IP Info" target="_blank" rel="noopener noreferrer">Netify</a>: <code>44.199.80.228</code>.</p><h2>Step 4: Making the Rule</h2><p>Following through the ZenArmor guide laid out the process for creating the rule quite well.</p><ul><li>Action: Block</li><li>TCP/IP: IPv4</li><li>Protocol: Any</li><li>Source: The Amazon devices</li><li>Port: Any</li><li>Destination: 44.199.80.228</li><li>Port: Any</li><li>Log: Blocking Amazon device transmission to Amazon Alexa server</li></ul><p>Interestingly, OPNsense has a feature called Aliases, which allows users to group multiple items together as sources/destinations for a rule.</p><p>So for this rule, I'll create an <code>AlexaSource</code> alias that contains 4 IP addresses: <code>192.168.##.#, 192.168.##.#, 192.168.##.#, 192.168.##.#</code></p><p>At this point, I think I have a proper rule ready, but let's see what the AI say.</p><h2>Step 5: Creating the Prompt</h2><p>In order to have a comparable result, we need to have a single prompt that is used by both LLMs. This is what I came up with:</p><blockquote><p>Make me an OPNsense firewall rule that does the following:</p><ul><li>Blocks traffic from a group of IP addresses called AlexaDevice going to the IP address(es) for Amazon's Alexa server(s)</li><li>Logs traffic with the message "Blocking Amazon device transmission to Amazon Alexa server"</li></ul></blockquote><h2>Step 6: ChatGPT</h2><p>Putting in the prompt generated this output:</p><blockquote><p>To create an OPNsense firewall rule that blocks traffic from a group of IP addresses (labeled "AlexaDevice") from reaching Amazon Alexa servers, while logging traffic with a custom message, follow these steps:<br><br><strong>Step 1: Create the "AlexaDevice" Alias</strong><br>- Go to **Firewall &gt; Aliases**.<br>- Click on the **+** button to create a new alias.<br>- Set **Name** to <code>AlexaDevice</code>.<br>- Set **Type** to <code>Host(s)</code>.<br>- Under **Content**, enter the list of IP addresses that belong to your Alexa devices.<br>- Click **Save** and then **Apply Changes**.<br><br><strong>Step 2: Create the Amazon Alexa Servers Alias</strong><br>- Go back to **Firewall &gt; Aliases**.<br>- Click the **+** button to create another alias.<br>- Set **Name** to <code>AmazonAlexaServers</code>.<br>- Set **Type** to <code>Host(s)</code> or <code>Network(s)</code>¬†(depending on the format of Amazon Alexa's IPs).<br>- Under **Content**, enter the IP addresses or subnets associated with Amazon Alexa servers. (You'll need to find Amazon Alexa server IPs, which may require researching their specific ranges.)<br>- Click **Save** and then **Apply Changes**.<br><br><strong>Step 3: Create the Block Rule in the Firewall</strong><br>- Navigate to **Firewall &gt; Rules &gt; LAN** (or the appropriate interface for your Alexa devices).<br>- Click the **+** button to add a new rule.<br>- Set **Action** to **Block**.<br>- Set **Interface** to **LAN** (or appropriate interface).<br>- Set **Protocol** to **Any** (since you may want to block all types of traffic).<br>- In the **Source** section:<br>¬† - Set **Source** to **Single Host or Alias**.<br>¬† - In the **Source Address**, choose the <code>AlexaDevice</code>¬†alias from the dropdown.<br>- In the **Destination** section:<br>¬† - Set **Destination** to **Single Host or Alias**.<br>¬† - In the **Destination Address**, choose the <code>AmazonAlexaServers</code>¬†alias from the dropdown.<br>- Under the **Log** section:<br>¬† - Check the **Log packets that are handled by this rule** option.<br>¬† - Add your custom log message in the **Description** box:¬†<br>¬† ¬† - <code>Blocking Amazon device transmission to Amazon Alexa server</code>.<br>- Click **Save** and then **Apply Changes**.<br><br><strong>Step 4: Apply Rule Changes</strong><br>- Go to the top right and click **Apply Changes** to activate your new rule.<br><br>This setup blocks traffic from devices in the **AlexaDevice** alias from reaching Amazon Alexa servers, logs those attempts, and tags them with the custom message you specified.</p></blockquote><p>Interestingly, ChatGPT gives me the full process to make the rule, but that's probably not surprising. Given the training data and refinements through use, the probabilities for responding to this question are almost certainly skewed more towards a step by step response than a simple table, like ZenArmor's examples.</p><h2>Step 7: Bing Copilot</h2><p>Putting in the prompt generated this output:</p><div class="content user-select-text" tabindex="0" aria-description="" aria-label="Sent by Copilot: Sure! Here's how you can create an OPNsense firewall rule to block traffic from a group of IP addresses called &#96;AlexaDevice&#96; to Amazon's Alexa servers and log the traffic with a specific message:

1. **Create Aliases**:
   - Go to **Firewall &gt; Aliases**.
   - Create an alias named &#96;AlexaDevice&#96; and add the IP addresses of your Alexa devices.
   - Create another alias named &#96;AmazonAlexaServers&#96; and add the IP addresses of Amazon's Alexa servers.

2. **Create the Firewall Rule**:
   - Go to **Firewall &gt; Rules &gt; [Your Interface]** (e.g., LAN).
   - Click on **Add** to create a new rule.
   - Set the following parameters:
     - **Action**: Block
     - **Interface**: [Your Interface] (e.g., LAN)
     - **Protocol**: Any
     - **Source**: Single host or alias, and select &#96;AlexaDevice&#96;
     - **Source Port Range**: Any
     - **Destination**: Single host or alias, and select &#96;AmazonAlexaServers&#96;
     - **Destination Port Range**: Any
     - **Description**: Blocking Amazon device transmission to Amazon Alexa server
     - **Log**: Check the box to enable logging
     - **Log Message**: &quot;Blocking Amazon device transmission to Amazon Alexa server&quot;

3. **Save and Apply**:
   - Click **Save** to save the rule.
   - Click **Apply Changes** to activate the rule.

This setup will block any traffic from the devices in the &#96;AlexaDevice&#96; alias to the &#96;AmazonAlexaServers&#96; alias and log the traffic with the specified message[^1^][^2^].

If you need further assistance, feel free to ask!"><div class="ac-container ac-adaptiveCard has-image"><div class="ac-textBlock"><blockquote><p>Sure! Here‚Äôs how you can create an OPNsense firewall rule to block traffic from a group of IP addresses called <code>AlexaDevice</code> to Amazon‚Äôs Alexa servers and log the traffic with a specific message:</p><ol><li><p><strong>Create Aliases</strong>:</p><ul><li>Go to <strong>Firewall &gt; Aliases</strong>.</li><li>Create an alias named <code>AlexaDevice</code> and add the IP addresses of your Alexa devices.</li><li>Create another alias named <code>AmazonAlexaServers</code> and add the IP addresses of Amazon‚Äôs Alexa servers.</li></ul></li><li><p><strong>Create the Firewall Rule</strong>:</p><ul><li>Go to <strong>Firewall &gt; Rules &gt; [Your Interface]</strong> (e.g., LAN).</li><li>Click on <strong>Add</strong> to create a new rule.</li><li>Set the following parameters:<ul><li><strong>Action</strong>: Block</li><li><strong>Interface</strong>: [Your Interface] (e.g., LAN)</li><li><strong>Protocol</strong>: Any</li><li><strong>Source</strong>: Single host or alias, and select <code>AlexaDevice</code></li><li><strong>Source Port Range</strong>: Any</li><li><strong>Destination</strong>: Single host or alias, and select <code>AmazonAlexaServers</code></li><li><strong>Destination Port Range</strong>: Any</li><li><strong>Description</strong>: Blocking Amazon device transmission to Amazon Alexa server</li><li><strong>Log</strong>: Check the box to enable logging</li><li><strong>Log Message</strong>: ‚ÄúBlocking Amazon device transmission to Amazon Alexa server‚Äù</li></ul></li></ul></li><li><p><strong>Save and Apply</strong>:</p><ul><li>Click <strong>Save</strong> to save the rule.</li><li>Click <strong>Apply Changes</strong> to activate the rule.</li></ul></li></ol><p><a href="https://homenetworkguy.com/how-to/firewall-rules-cheat-sheet/" class="tooltip-target" data-citationid="53673d85-94e0-1d56-5b27-7e8b36d59e71-59-group" h="ID=SERP,5015.1" target="_blank" rel="noopener">This setup will block any traffic from the devices in the <code>AlexaDevice</code> alias to the <code>AmazonAlexaServers</code> alias and log the traffic with the specified message</a><a href="https://homenetworkguy.com/how-to/firewall-rules-cheat-sheet/" class="ac-anchor sup-target" target="_blank" data-citationid="53673d85-94e0-1d56-5b27-7e8b36d59e71-57" aria-label="1: AmazonAlexaServers" h="ID=SERP,5015.1" rel="noopener"><sup class="citation-sup">1</sup></a><a href="https://forum.opnsense.org/index.php?topic=34331.0" class="ac-anchor sup-target" target="_blank" data-citationid="53673d85-94e0-1d56-5b27-7e8b36d59e71-59" aria-label="2: AmazonAlexaServers" h="ID=SERP,5015.1" rel="noopener"><sup class="citation-sup">2</sup></a>.</p><p>If you need further assistance, feel free to ask!</p></blockquote></div><div class="ac-horizontal-separator" aria-hidden="true">¬†</div></div><div class="ad-container">Bing Copilot's response is a lot more comparable to my own writing and is honestly easier to read, although it's presupposing a higher level of knowledge/tech competence from the user.</div><h2>Which is Better?</h2><p>Without the ability to actually test these, it's hard to say. Here's what I can tell from looking at both responses and comparing to my own:</p><ul><li>ChatGPT gives more detail on how to actually set the options, and includes setup instructions for the aliases.</li><li>Bing Copilot is more easily readable and faster to copy the settings from.</li><li>Both of the AI responses don't set the IP version, which means that was an optional setting I didn't need to set.</li><li>Neither of the AI responses included an actual IP address for Alexa's servers.</li></ul><p>Interestingly, neither of the LLM generated replies attempted to provide an actual IP address for Alexa's server(s). That's something to keep in mind for future use: if it's not explicitly pointed out by the prompt, it won't get done.</p><h2>What's Next?</h2><p>Since OPNsense is still a no go for now, actually testing out this rule is a no-go.</p><p>So what I'll do is move onto an even harder step, creating Suricata rules, which I¬†<em>can¬†</em>test.</p></div></div><footer class="content__footer"><div class="content__tag-share"><div class="content__tag"><h3 class="content__tag__title">Posted in</h3><ul class="content__tag__list"><li><a href="https://korgano.github.io/tags/ai/">AI</a></li><li><a href="https://korgano.github.io/tags/cybersecurity/">Cybersecurity</a></li><li><a href="https://korgano.github.io/tags/cybersecurity-projects/">Cybersecurity Projects</a></li><li><a href="https://korgano.github.io/tags/tech/">Tech</a></li></ul></div><div class="content__share"><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fkorgano.github.io%2Fcybersecurity-project-transparent-filtering-bridge-extras-30%2F" class="js-share linkedin" aria-label="Share with LinkedIn" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://korgano.github.io/assets/svg/svg-map.svg#linkedin"/></svg></a></div></div></footer></div></article><div class="content__related"><h3 class="content__related__title">Related posts</h3><div class="l-grid l-grid--2"><article class="c-card"><div class="c-card__wrapper"><figure class="c-card__image is-img-loading"><img src="https://korgano.github.io/media/posts/10/glenn-carstens-peters-npxXWgQ33ZQ-unsplash.jpg" srcset="https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-xs.jpg 384w, https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-sm.jpg 600w, https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-md.jpg 768w, https://korgano.github.io/media/posts/10/responsive/glenn-carstens-peters-npxXWgQ33ZQ-unsplash-lg.jpg 1200w" sizes="(min-width: 37.5em) 80vw, 50vw" loading="lazy" height="2712" width="4076" alt=""></figure><div class="c-card__content"><header><h2 class="c-card__title"><a href="https://korgano.github.io/cybersecurity-project-research-remote-access/" class="invert">Cybersecurity Project Research: Remote Access</a></h2></header><footer class="c-card__meta"><a href="https://korgano.github.io/tags/cybersecurity-projects/" class="c-card__tag">Cybersecurity Projects</a></footer></div></div></article><article class="c-card"><div class="c-card__wrapper"><figure class="c-card__image is-img-loading"><img src="https://korgano.github.io/media/posts/9/andres-urena-vXPXRp_wIg4-unsplash.jpg" srcset="https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-xs.jpg 384w, https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-sm.jpg 600w, https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-md.jpg 768w, https://korgano.github.io/media/posts/9/responsive/andres-urena-vXPXRp_wIg4-unsplash-lg.jpg 1200w" sizes="(min-width: 37.5em) 80vw, 50vw" loading="lazy" height="1687" width="3000" alt=""></figure><div class="c-card__content"><header><h2 class="c-card__title"><a href="https://korgano.github.io/cybersecurity-headache-home-router-uxui/" class="invert">Cybersecurity Headache: Home Router UXUI</a></h2></header><footer class="c-card__meta"><a href="https://korgano.github.io/tags/quick-thoughts/" class="c-card__tag">Quick Thoughts</a></footer></div></div></article></div></div></main><footer class="footer"><div class="footer__left"><div class="footer__copy">Copyright Xavier Santana, 2023-2024. Powered by Publii.</div></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://korgano.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = { mobileMenuMode: 'sidebar', animationSpeed: 300, submenuWidth: 'auto', doubleClickTime: 500, mobileMenuExpandableSubmenus: true, relatedContainerForOverlayMenuSelector: '.navbar', };</script><script defer="defer" src="https://korgano.github.io/assets/js/scripts.min.js?v=9c5ab7a87221183f149a42b3cceb7956"></script><script>function publiiDetectLoadedImages () {
         var images = document.querySelectorAll('img[loading]:not(.is-loaded)');
         for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
               images[i].classList.add('is-loaded');
               images[i].parentNode.classList.remove('is-img-loading');
            } else {
               images[i].addEventListener('load', function () {
                  this.classList.add('is-loaded');
                  this.parentNode.classList.remove('is-img-loading');
               }, false);
            }
         }
      }
      publiiDetectLoadedImages();</script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-line-numbers.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/clipboard.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-copy-to-clipboard.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-inline-color.min.js"></script><script defer="defer" src="https://korgano.github.io/media/plugins/syntaxHighlighter/prism-show-invisibles.min.js"></script><!-- Start main cookie container --><div class="pcb" data-behaviour="badge" data-behaviour-link="#cookie-settings" data-revision="1" data-config-ttl="90" data-debug-mode="false"><!-- Start Banner --><div role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="pcb-title" aria-describedby="pcb-txt" class="pcb__banner"><div class="pcb__inner"><div id="pcb-title" role="heading" aria-level="2" class="pcb__title">This website uses cookies</div><div id="pcb-txt" class="pcb__txt">Select which cookies to opt-in to via the checkboxes below; our website uses cookies to examine site traffic and user activity while on our site, for marketing, and to provide social media functionality. <a href="https://korgano.github.io/privacy-policy/">More details...</a></div><div class="pcb__buttons"><button type="button" class="pcb__btn pcb__btn--solid pcb__btn--accept">Accept all</button></div></div></div><!-- End of Banner --><!-- Badge --> <button class="pcb__badge" aria-label="Cookie Policy" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" width="40" height="40" viewBox="0 0 23 23" fill="currentColor"><path d="M21.41 12.71c-.08-.01-.15 0-.22 0h-.03c-.03 0-.05 0-.08.01-.07 0-.13.01-.19.04-.52.21-1.44.19-2.02-.22-.44-.31-.65-.83-.62-1.53a.758.758 0 0 0-.27-.61.73.73 0 0 0-.65-.14c-1.98.51-3.49.23-4.26-.78-.82-1.08-.73-2.89.24-4.49.14-.23.14-.52 0-.75a.756.756 0 0 0-.67-.36c-.64.03-1.11-.1-1.31-.35-.19-.26-.13-.71-.01-1.29.04-.18.06-.38.03-.59-.05-.4-.4-.7-.81-.66C5.1 1.54 1 6.04 1 11.48 1 17.28 5.75 22 11.6 22c5.02 0 9.39-3.54 10.39-8.42.08-.4-.18-.78-.58-.87Zm-9.81 7.82c-5.03 0-9.12-4.06-9.12-9.06 0-4.34 3.05-8 7.25-8.86-.08.7.05 1.33.42 1.81.24.32.66.67 1.38.84-.76 1.86-.65 3.78.36 5.11.61.81 2.03 2 4.95 1.51.18.96.71 1.54 1.18 1.87.62.43 1.38.62 2.1.62.05 0 .09 0 .13-.01-1.23 3.64-4.7 6.18-8.64 6.18ZM13 17c0 .55-.45 1-1 1s-1-.45-1-1 .45-1 1-1 1 .45 1 1Zm5.29-12.3a.99.99 0 0 1-.29-.71c0-.55.45-.99 1-.99a1 1 0 0 1 .71.3c.19.19.29.44.29.71 0 .55-.45.99-1 .99a1 1 0 0 1-.71-.3ZM9 13.5c0 .83-.67 1.5-1.5 1.5S6 14.33 6 13.5 6.67 12 7.5 12s1.5.67 1.5 1.5Zm3.25.81a.744.744 0 0 1-.06-1.05c.28-.32.75-.34 1.05-.06.31.28.33.75.05 1.06-.15.16-.35.25-.56.25-.18 0-.36-.06-.5-.19ZM8.68 7.26c.41.37.44 1 .07 1.41-.2.22-.47.33-.75.33a.96.96 0 0 1-.67-.26c-.41-.37-.44-1-.07-1.41.37-.42 1-.45 1.41-.08Zm11.48 1.88c.18-.19.52-.19.7 0 .05.04.09.1.11.16.03.06.04.12.04.19 0 .13-.05.26-.15.35-.09.1-.22.15-.35.15s-.26-.05-.35-.15a.355.355 0 0 1-.11-.16.433.433 0 0 1-.04-.19c0-.13.05-.26.15-.35Zm-4.93-1.86a.75.75 0 1 1 1.059-1.06.75.75 0 0 1-1.059 1.06Z"/></svg></button><!-- End of Badge --></div><!-- End of main cookie container --><script>(function(win) {
    if (!document.querySelector('.pcb')) {
        return;
    }

    var cbConfig = {
        behaviour: document.querySelector('.pcb').getAttribute('data-behaviour'),
        behaviourLink: document.querySelector('.pcb').getAttribute('data-behaviour-link'),
        revision: document.querySelector('.pcb').getAttribute('data-revision'),
        configTTL: parseInt(document.querySelector('.pcb').getAttribute('data-config-ttl'), 10),
        debugMode: document.querySelector('.pcb').getAttribute('data-debug-mode') === 'true',
        initialState: null,
        initialLsState: null,
        previouslyAccepted: []
    };

    var cbUI = {
        wrapper: document.querySelector('.pcb'),
        banner: {
            element: null,
            btnAccept: null,
            btnReject: null,
            btnConfigure: null
        },
        popup: {
            element: null,
            btnClose: null,
            btnSave: null,
            btnAccept: null,
            btnReject: null,
            checkboxes: null,
        },
        overlay: null,
        badge: null,
        blockedScripts: document.querySelectorAll('script[type^="gdpr-blocker/"]'),
        triggerLinks: cbConfig.behaviourLink ? document.querySelectorAll('a[href*="' + cbConfig.behaviourLink + '"]') : null
    };

    function initUI () {
        // setup banner elements
        cbUI.banner.element = cbUI.wrapper.querySelector('.pcb__banner');
        cbUI.banner.btnAccept = cbUI.banner.element.querySelector('.pcb__btn--accept');
        cbUI.banner.btnReject = cbUI.banner.element.querySelector('.pcb__btn--reject');
        cbUI.banner.btnConfigure = cbUI.banner.element.querySelector('.pcb__btn--configure');

        // setup popup elements
        if (cbUI.wrapper.querySelector('.pcb__popup')) {
            cbUI.popup.element = cbUI.wrapper.querySelector('.pcb__popup');
            cbUI.popup.btnClose = cbUI.wrapper.querySelector('.pcb__popup__close');
            cbUI.popup.btnSave = cbUI.popup.element.querySelector('.pcb__btn--save');
            cbUI.popup.btnAccept = cbUI.popup.element.querySelector('.pcb__btn--accept');
            cbUI.popup.btnReject = cbUI.popup.element.querySelector('.pcb__btn--reject');
            cbUI.popup.checkboxes = cbUI.popup.element.querySelector('input[type="checkbox"]');
            // setup overlay
            cbUI.overlay = cbUI.wrapper.querySelector('.pcb__overlay');
        }

        cbUI.badge = cbUI.wrapper.querySelector('.pcb__badge');

        if (cbConfig.behaviour.indexOf('link') > -1) {
            for (var i = 0; i < cbUI.triggerLinks.length; i++) {
                cbUI.triggerLinks[i].addEventListener('click', function(e) {
                    e.preventDefault();
                    showBannerOrPopup();
                });
            }
        }
    }

    function initState () {
        var lsKeyName = getConfigName();
        var currentConfig = localStorage.getItem(lsKeyName);
        var configIsFresh = checkIfConfigIsFresh();

        if (!configIsFresh || currentConfig === null) {
            if (cbConfig.debugMode) {
                console.log('üç™ Config not found, or configuration expired');
            }

            if (window.publiiCBGCM) {
                gtag('consent', 'default', {
                    'ad_storage': window.publiiCBGCM.defaultState.ad_storage ? 'granted' : 'denied',
                    'ad_personalization': window.publiiCBGCM.defaultState.ad_personalization ? 'granted' : 'denied',
                    'ad_user_data': window.publiiCBGCM.defaultState.ad_user_data ? 'granted' : 'denied',
                    'analytics_storage': window.publiiCBGCM.defaultState.analytics_storage ? 'granted' : 'denied',
                    'personalization_storage': window.publiiCBGCM.defaultState.personalization_storage ? 'granted' : 'denied',
                    'functionality_storage': window.publiiCBGCM.defaultState.functionality_storage ? 'granted' : 'denied',
                    'security_storage': window.publiiCBGCM.defaultState.security_storage ? 'granted' : 'denied'
                });  
                
                if (cbConfig.debugMode) {
                    console.log('üç™ GCMv2 DEFAULT STATE: ' + JSON.stringify({
                        'ad_storage': window.publiiCBGCM.defaultState.ad_storage ? 'granted' : 'denied',
                        'ad_personalization': window.publiiCBGCM.defaultState.ad_personalization ? 'granted' : 'denied',
                        'ad_user_data': window.publiiCBGCM.defaultState.ad_user_data ? 'granted' : 'denied',
                        'analytics_storage': window.publiiCBGCM.defaultState.analytics_storage ? 'granted' : 'denied',
                        'personalization_storage': window.publiiCBGCM.defaultState.personalization_storage ? 'granted' : 'denied',
                        'functionality_storage': window.publiiCBGCM.defaultState.functionality_storage ? 'granted' : 'denied',
                        'security_storage': window.publiiCBGCM.defaultState.security_storage ? 'granted' : 'denied'
                    }));
                }
            }

            showBanner();
        } else if (typeof currentConfig === 'string') {
            if (cbConfig.debugMode) {
                console.log('üç™ Config founded');
            }

            cbConfig.initialLsState = currentConfig.split(',');

            if (window.publiiCBGCM) {
                gtag('consent', 'default', {
                    'ad_storage': getDefaultConsentState(currentConfig, 'ad_storage'),
                    'ad_personalization': getDefaultConsentState(currentConfig, 'ad_personalization'),
                    'ad_user_data': getDefaultConsentState(currentConfig, 'ad_user_data'),
                    'analytics_storage': getDefaultConsentState(currentConfig, 'analytics_storage'),
                    'personalization_storage': getDefaultConsentState(currentConfig, 'personalization_storage'),
                    'functionality_storage': getDefaultConsentState(currentConfig, 'functionality_storage'),
                    'security_storage': getDefaultConsentState(currentConfig, 'security_storage')
                });
                
                if (cbConfig.debugMode) {
                    console.log('üç™ GCMv2 DEFAULT STATE: ' + JSON.stringify({
                        'ad_storage': getDefaultConsentState(currentConfig, 'ad_storage'),
                        'ad_personalization': getDefaultConsentState(currentConfig, 'ad_personalization'),
                        'ad_user_data': getDefaultConsentState(currentConfig, 'ad_user_data'),
                        'analytics_storage': getDefaultConsentState(currentConfig, 'analytics_storage'),
                        'personalization_storage': getDefaultConsentState(currentConfig, 'personalization_storage'),
                        'functionality_storage': getDefaultConsentState(currentConfig, 'functionality_storage'),
                        'security_storage': getDefaultConsentState(currentConfig, 'security_storage')
                    }));
                }
            }

            showBadge();

            if (cbUI.popup.element) {
                var allowedGroups = currentConfig.split(',');
                var checkedCheckboxes = cbUI.popup.element.querySelectorAll('input[type="checkbox"]:checked');

                for (var j = 0; j < checkedCheckboxes.length; j++) {
                    var name = checkedCheckboxes[j].getAttribute('data-group-name');

                    if (name && name !== '-' && allowedGroups.indexOf(name) === -1) {
                        checkedCheckboxes[j].checked = false;
                    }
                }

                for (var i = 0; i < allowedGroups.length; i++) {
                    var checkbox = cbUI.popup.element.querySelector('input[type="checkbox"][data-group-name="' + allowedGroups[i] + '"]');

                    if (checkbox) {
                        checkbox.checked = true;
                    }

                    allowCookieGroup(allowedGroups[i]);
                }
            }
        }

        setTimeout(function () {
            cbConfig.initialState = getInitialStateOfConsents();
        }, 0);
    }

    function checkIfConfigIsFresh () {
        var lastConfigSave = localStorage.getItem('publii-gdpr-cookies-config-save-date');

        if (lastConfigSave === null) {
            return false;
        }

        lastConfigSave = parseInt(lastConfigSave, 10);

        if (lastConfigSave === 0) {
            return true;
        }

        if (+new Date() - lastConfigSave < cbConfig.configTTL * 24 * 60 * 60 * 1000) {
            return true;
        }

        return false;
    }

    function getDefaultConsentState (currentConfig, consentGroup) {
        let configGroups = currentConfig.split(',');

        for (let i = 0; i < configGroups.length; i++) {
            let groupName = configGroups[i];
            let group = window.publiiCBGCM.groups.find(group => group.cookieGroup === groupName);

            if (group && group[consentGroup]) {
                return 'granted';
            }
        }  
        
        if (window.publiiCBGCM.defaultState[consentGroup]) {
            return 'granted'; 
        }
        
        return 'denied';
    }

    function initBannerEvents () {
        cbUI.banner.btnAccept.addEventListener('click', function (e) {
            e.preventDefault();
            acceptAllCookies('banner');
            showBadge();
        }, false);

        if (cbUI.banner.btnReject) {
            cbUI.banner.btnReject.addEventListener('click', function (e) {
                e.preventDefault();
                rejectAllCookies();
                showBadge();
            }, false);
        }

        if (cbUI.banner.btnConfigure) {
            cbUI.banner.btnConfigure.addEventListener('click', function (e) {
                e.preventDefault();
                hideBanner();
                showAdvancedPopup();
                showBadge();
            }, false);
        }
    }

    function initPopupEvents () {
        if (!cbUI.popup.element) {
            return;
        }

        cbUI.overlay.addEventListener('click', function (e) {
            hideAdvancedPopup();
        }, false);

        cbUI.popup.element.addEventListener('click', function (e) {
            e.stopPropagation();
        }, false);

        cbUI.popup.btnAccept.addEventListener('click', function (e) {
            e.preventDefault();
            acceptAllCookies('popup');
        }, false);

        cbUI.popup.btnReject.addEventListener('click', function (e) {
            e.preventDefault();
            rejectAllCookies();
        }, false);

        cbUI.popup.btnSave.addEventListener('click', function (e) {
            e.preventDefault();
            saveConfiguration();
        }, false);

        cbUI.popup.btnClose.addEventListener('click', function (e) {
            e.preventDefault();
            hideAdvancedPopup();
        }, false);
    }

    function initBadgeEvents () {
        if (!cbUI.badge) {
            return;
        }

        cbUI.badge.addEventListener('click', function (e) {
            showBannerOrPopup();
        }, false);
    }

    initUI();
    initState();
    initBannerEvents();
    initPopupEvents();
    initBadgeEvents();

    /**
     * API
     */
    function addScript (src, inline) {
        var newScript = document.createElement('script');

        if (src) {
            newScript.setAttribute('src', src);
        }

        if (inline) {
            newScript.text = inline;
        }

        document.body.appendChild(newScript);
    }

    function allowCookieGroup (allowedGroup) {
        var scripts = document.querySelectorAll('script[type="gdpr-blocker/' + allowedGroup + '"]');
        cbConfig.previouslyAccepted.push(allowedGroup);
    
        for (var j = 0; j < scripts.length; j++) {
            addScript(scripts[j].src, scripts[j].text);
        }

        var groupEvent = new Event('publii-cookie-banner-unblock-' + allowedGroup);
        document.body.dispatchEvent(groupEvent);
        unlockEmbeds(allowedGroup);

        if (cbConfig.debugMode) {
            console.log('üç™ Allowed group: ' + allowedGroup);
        }

        if (window.publiiCBGCM && cbConfig.initialLsState.indexOf(allowedGroup) === -1) {
            let consentResult = {};
            let group = window.publiiCBGCM.groups.find(group => group.cookieGroup === allowedGroup);

            if (group) {
                let foundSomeConsents = false;

                Object.keys(group).forEach(key => {
                    if (key !== 'cookieGroup' && group[key] === true) {
                        consentResult[key] = 'granted';
                        foundSomeConsents = true;
                    }
                });

                if (foundSomeConsents) {
                    gtag('consent', 'update', consentResult);   

                    if (cbConfig.debugMode) {
                        console.log('üç™ GCMv2 UPDATE: ' + JSON.stringify(consentResult));
                    }
                }
            }
        }
    }

    function showBannerOrPopup () {
        if (cbUI.popup.element) {
            showAdvancedPopup();
        } else {
            showBanner();
        }
    }

    function showAdvancedPopup () {
        cbUI.popup.element.classList.add('is-visible');
        cbUI.overlay.classList.add('is-visible');
        cbUI.popup.element.setAttribute('aria-hidden', 'false');
        cbUI.overlay.setAttribute('aria-hidden', 'false');
    }

    function hideAdvancedPopup () {
        cbUI.popup.element.classList.remove('is-visible');
        cbUI.overlay.classList.remove('is-visible');
        cbUI.popup.element.setAttribute('aria-hidden', 'true');
        cbUI.overlay.setAttribute('aria-hidden', 'true');
    }

    function showBanner () {
        cbUI.banner.element.classList.add('is-visible');
        cbUI.banner.element.setAttribute('aria-hidden', 'false');
    }

    function hideBanner () {
        cbUI.banner.element.classList.remove('is-visible');
        cbUI.banner.element.setAttribute('aria-hidden', 'true');
    }

    function showBadge () {
        if (!cbUI.badge) {
            return;
        }

        cbUI.badge.classList.add('is-visible');
        cbUI.badge.setAttribute('aria-hidden', 'false');
    }

    function getConfigName () {
        var lsKeyName = 'publii-gdpr-allowed-cookies';

        if (cbConfig.revision) {
            lsKeyName = lsKeyName + '-v' + parseInt(cbConfig.revision, 10);
        }

        return lsKeyName;
    }

    function storeConfiguration (allowedGroups) {
        var lsKeyName = getConfigName();
        var dataToStore = allowedGroups.join(',');
        localStorage.setItem(lsKeyName, dataToStore);

        if (cbConfig.configTTL === 0) {
            localStorage.setItem('publii-gdpr-cookies-config-save-date', 0);

            if (cbConfig.debugMode) {
                console.log('üç™ Store never expiring configuration');
            }
        } else {
            localStorage.setItem('publii-gdpr-cookies-config-save-date', +new Date());
        }
    }

    function getInitialStateOfConsents () {
        if (!cbUI.popup.element) {
            return [];
        }

        var checkedGroups = cbUI.popup.element.querySelectorAll('input[type="checkbox"]:checked');
        var groups = [];

        for (var i = 0; i < checkedGroups.length; i++) {
            var allowedGroup = checkedGroups[i].getAttribute('data-group-name');

            if (allowedGroup !== '') {
                groups.push(allowedGroup);
            }
        }

        if (cbConfig.debugMode) {
            console.log('üç™ Initial state: ' + groups.join(', '));
        }

        return groups;
    }

    function getCurrentStateOfConsents () {
        if (!cbUI.popup.element) {
            return [];
        }

        var checkedGroups = cbUI.popup.element.querySelectorAll('input[type="checkbox"]:checked');
        var groups = [];

        for (var i = 0; i < checkedGroups.length; i++) {
            var allowedGroup = checkedGroups[i].getAttribute('data-group-name');

            if (allowedGroup !== '') {
                groups.push(allowedGroup);
            }
        }

        if (cbConfig.debugMode) {
            console.log('üç™ State to save: ' + groups.join(', '));
        }

        return groups;
    }

    function getAllGroups () {
        if (!cbUI.popup.element) {
            return [];
        }

        var checkedGroups = cbUI.popup.element.querySelectorAll('input[type="checkbox"]');
        var groups = [];

        for (var i = 0; i < checkedGroups.length; i++) {
            var allowedGroup = checkedGroups[i].getAttribute('data-group-name');

            if (allowedGroup !== '') {
                groups.push(allowedGroup);
            }
        }

        return groups;
    }

    function acceptAllCookies (source) {
        var groupsToAccept = getAllGroups();
        storeConfiguration(groupsToAccept);

        for (var i = 0; i < groupsToAccept.length; i++) {
            var group = groupsToAccept[i];

            if (cbConfig.initialState.indexOf(group) > -1 || cbConfig.previouslyAccepted.indexOf(group) > -1) {
                if (cbConfig.debugMode) {
                    console.log('üç™ Skip previously activated group: ' + group);
                }

                continue;
            }

            allowCookieGroup(group);
        }

        if (cbUI.popup.element) {
            var checkboxesToCheck = cbUI.popup.element.querySelectorAll('input[type="checkbox"]');

            for (var j = 0; j < checkboxesToCheck.length; j++) {
                checkboxesToCheck[j].checked = true;
            }
        }

        if (cbConfig.debugMode) {
            console.log('üç™ Accept all cookies: ', groupsToAccept.join(', '));
        }

        if (source === 'popup') {
            hideAdvancedPopup();
        } else if (source === 'banner') {
            hideBanner();
        }
    }

    function rejectAllCookies () {
        if (cbConfig.debugMode) {
            console.log('üç™ Reject all cookies');
        }

        storeConfiguration([]);
        setTimeout(function () {
            window.location.reload();
        }, 100);
    }

    function saveConfiguration () {
        var groupsToAccept = getCurrentStateOfConsents();
        storeConfiguration(groupsToAccept);

        if (cbConfig.debugMode) {
            console.log('üç™ Save new config: ', groupsToAccept.join(', '));
        }

        if (reloadIsNeeded(groupsToAccept)) {
            setTimeout(function () {
                window.location.reload();
            }, 100);
            return;
        }

        for (var i = 0; i < groupsToAccept.length; i++) {
            var group = groupsToAccept[i];

            if (cbConfig.initialState.indexOf(group) > -1 || cbConfig.previouslyAccepted.indexOf(group) > -1) {
                if (cbConfig.debugMode) {
                    console.log('üç™ Skip previously activated group: ' + group);
                }

                continue;
            }

            allowCookieGroup(group);
        }

        hideAdvancedPopup();
    }

    function reloadIsNeeded (groupsToAccept) {
        // check if user rejected consent for initial groups
        var initialGroups = cbConfig.initialState;
        var previouslyAcceptedGroups = cbConfig.previouslyAccepted;
        var groupsToCheck = initialGroups.concat(previouslyAcceptedGroups);

        for (var i = 0; i < groupsToCheck.length; i++) {
            var groupToCheck = groupsToCheck[i];

            if (groupToCheck !== '' && groupsToAccept.indexOf(groupToCheck) === -1) {
                if (cbConfig.debugMode) {
                    console.log('üç™ Reload is needed due lack of: ', groupToCheck);
                }

                return true;
            }
        }

        return false;
    }

    function unlockEmbeds (cookieGroup) {
        var iframesToUnlock = document.querySelectorAll('.pec-wrapper[data-consent-group-id="' + cookieGroup + '"]');

        for (var i = 0; i < iframesToUnlock.length; i++) {
            var iframeWrapper = iframesToUnlock[i];
            iframeWrapper.querySelector('.pec-overlay').classList.remove('is-active');
            iframeWrapper.querySelector('.pec-overlay').setAttribute('aria-hidden', 'true');
            var iframe = iframeWrapper.querySelector('iframe');
            iframe.setAttribute('src', iframe.getAttribute('data-consent-src'));
        }
    }

    win.publiiEmbedConsentGiven = function (cookieGroup) {
        // it will unlock embeds
        allowCookieGroup(cookieGroup);

        var checkbox = cbUI.popup.element.querySelector('input[type="checkbox"][data-group-name="' + cookieGroup + '"]');

        if (checkbox) {
            checkbox.checked = true;
        }

        var groupsToAccept = getCurrentStateOfConsents();
        storeConfiguration(groupsToAccept);

        if (cbConfig.debugMode) {
            console.log('üç™ Save new config: ', groupsToAccept.join(', '));
        }
    }
})(window);</script></body></html>